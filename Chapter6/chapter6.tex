\chapter{The third protocol - Computing and Comparing HD Homomorphically}
\label{chap:thirdProtocol}

% **************************** Define Graphics Path **************************
\ifpdf
\graphicspath{{Chapter5/Figs/Raster/}{Chapter5/Figs/PDF/}{Chapter5/Figs/}}
\else
\graphicspath{{Chapter5/Figs/Vector/}{Chapter5/Figs/}}
\fi

% **** main chapter

\section{Introduction}
\label{sub:introChap3}
In the previous chapter, we assumed that, given the Hamming Distance (HD) between the registered and queried
binary bitstring templates, it is infeasible for an attacker to infer or acquire any information
about the registered templates stored on the server. This assumption is plausible as long as the
distributions of the HD between registered and the queried templates is not in any way
correlated to the templates themselves (analysing these distributions is out of scope of the
project). However, in this chapter, we introduce our first attempt to hide 
information from the server as well. Our results not only cause the protocol
to work regardless of the aforementioned dependencies, it is also the first step we take to
secure the authentication protocol against an \textit{active} server security model. Although the communication size of this variant might not
be suitable in practice for current network infrastructures, one can
still find some generic techniques used within it to be helpful while
applying them to balance the computation time and the communication size of
lattice-based cryptographic protocols. The contributions of this variant include:
\begin{itemize}
\item A technique to compare Hamming Distance (HD) homomorphically by computing
  the Most Significant Bit (MSB) of a specific ciphertext.
\item A packing methods conversion technique to transform a ciphertext
  encrypting a binary-encoded to a unary-encoded plaintext.
\item Some extensions of the Zero Knowledge Proof (ZKP) technique we used
  in previous chapter to check the format of a message, in addition to the
  information carried by the plaintext itself.
\item The combination of ZKP protocols to balance the communication size
  trade-offs when used with lattice-based cryptosystems.
\end{itemize}


\section{Proposed Scheme}
We first propose a secure fingerprint authentication scheme that combines a
Somewhat Homomorphic Encryption (SHE) with a Zero-Knowledge Proof (ZKP) to
provide privacy features with low FAR overhead. The scheme is secure under a
hybrid model that assumes an active client and an honest but curious (HBC)
server. The server $\server$ is considered to be HBC by assuming that it can be
audited regularly. This scheme uses Hamming Distance (HD) as the main measure
unit to determine the difference between two fingerprint templates. The detailed
descriptions of each protocol step are discussed in later sections of the
chapter. Together with notations according to previous chapter, we use extra notations regarding encryptions as follows:
\begin{itemize}
\item $Enc^{(1)}(m)$: The BV encryption of $m$ as in previous chapter.
\item $Enc^{(2)}(m)$: The BV encryption of $x^{m}$: $Enc^{(2)}(m) = Enc^{(1)}(x^{m})$
\item $Enc^{(3)}(m)$: The LWE encryption of $m$ over $\mathbb{Z}_{Q}$ defined in section \ref{def:PublicKeyIndCPARegev}.
\end{itemize}

\subsection{The protocol}
\label{sec:theProtocol}
\begin{description}
	\item[Setup] The server and the user run the setup process as
	follows:
	\begin{itemize}



		% * <trung.dinh@monash.edu> 2016-10-21T13:17:43.354Z:
		%
		% replace BGV by GSW for now
		%
		% ^.

		\item $\mathcal{S}$ invokes $params_{BV} \gets
		SGen_{BV}(1^\lambda)$
		\item We are currently using a BV cryptosystem
		(\cite{brakerski2011fully}). We refer the reader to section
		\ref{sec:BVScheme} for details of $params_{BV}$, the public
		key $pk$, the private key $sk$, as well as the
		operations of the
		cryptosystem.
		\item A user $\mathcal{U}_k$ invokes $(pk_k,sk_k) \gets
		UGen_{BGV}(params_{BGV})$ and makes $pk_k$ publicly
		available to $\mathcal{S}$.




		\iffalse
		\item $\mathcal{S}$ invokes $params_{GSW} \gets
		SGen_{GSW}(1^\lambda)$
		\item We are currently using GSW cryptosystem
		(\cite{gentry2013homomorphic}).
		We refer the reader to section
		\missref{} for details of $params_{GSW}$, the public
		key $pk$, the private key $sk$, as well as the
		homomorphic operations of the
		cryptosystem.
		\item A user $\mathcal{U}_k$ invokes $(pk_k,sk_k) \gets
		UGen_{GSW}(params_{GSW})$ and make $pp_k$ publicly
		available to $\mathcal{S}$
		\fi


	\end{itemize}
	\item[Enrolment] The enrolment process runs as follows.
	\begin{itemize}
		\item $\mathcal{U}$ uses a specific sensor and algorithm to
		extract his biometric template $X$. $\mathcal{U}$
		encrypts $X$ with his public key $pk_k$ to get
		$T_k = Enc^{(1)}(X)$.
		\item $\mathcal{U}$ sends $(k,T_k)$ to $\mathcal{S}$.
		Noted that $k$
		is used as an identity index for $\mathcal{U}$.
		\item $\mathcal{S}$ stores a tuple $(k, T_k)$ as a
		record.
	\end{itemize}
	\item[Authentication] The authentication process for a user
	$\mathcal{U}_k$ is as follows.
	\begin{enumerate}
		\item $\user_k$ extracts his query template $Y$. He
		encrypts $Y$ with his public key $pk_k$ to obtain
		$Q_k = Enc^{(1)}(Y)$.\label{protocol:step1}
              \item $\user_k$ sends $(k,Q_k)$ to $\server$ and runs
                $\mathbf{ZKPValidEnc((Q_k,pk_k),(Y,sk_k))}$ to prove the
                validity of $Y$.\label{protocol:step2} was detailed in Chapter \ref{chap:firstProtocol}.
              \item $\server$ locates the record $(k,T_k)$ and computes \ the
                encrypted Hamming Distance $C_{HD} = Enc^{(1)}( HD)$ of $X$ and
                $Y$, using the homomorphic operation discussed in Section \ref{sec:firstProcBGV}.
		$$C_{HD} \gets
		\textbf{EvalDistance}(T_k,Q_k).$$\label{protocol:step3}
		\item $\server$ masks the $C_{HD}$ by sampling $r
		\randomsample \mathcal{P}$
		and performs one homomorphic addition to get
		$C_{HD'} = Enc^{(1)}(HD + r) \gets Enc^{(1)}(HD) + Enc^{(1)}(r)$.
		The result ciphertext is sent to $\user_k$.\label{protocol:step4}
		\item $\user_k$ uses his private key $sk_k$ to decrypt $C_{HD'}$
		and sends
		the re-encryption $C_{HD'_0} = Enc^{(1)}(HD',0,0,\dots,0)$ back to $\server$.
		$\user_k$ also decomposes the plaintext result
		$HD' = HD+r$ into its binary representation:
		\[
		HD' = b_0 + b_12^1 + \dots + b_l2^{l-1}
		\]
		and sends $C_i = Enc^{(1)}(b_i)$ to $\server$
		for $i = 0, \dots, l-1$.\label{protocol:step5}

		\item $\user_k$ and $\server$ run the $\mathbf{ZKPUnpack}(C_{HD},C_{HD_0'})$ and
		$\mathbf{ZKPBinDecomp}(C_{HD_0'},C_i)$
		protocols to convince the server that
		$\user_k$ did follow the protocol transcript correctly. This is detailed
		in section
		\ref{sec:ZKPReencrypt}.
		\label{protocol:step6}
		\item $\server$ computes $C_{HD}'' = Enc^{(2)}(2^l + t - HD) \gets
		Enc^{(2)}(2^l + t) - Enc^{(2)}(HD+r) + Enc^{(2)}(r)$, where
		$Enc^{(2)}(HD + r)$ is computed by $\mathbf{ToUnary}(C_i)$. We note that
		$Enc^{(2)}$ is the ``unary'' mode of encryption with the message
		encoded in the exponent of the polynomial, which allows the
		Most significat bit (MSB)
		extraction on the ciphertext (this is detailed section \ref{sec:binToUna} \label{protocol:step7}).
		\item $\server$ does $Enc^{(3)}(res) \gets
		\mathbf{MSBExtract}(C_{HD}'')$, this is the ciphertext
		of the authentication result, which is sent to $\user_k$. This
		is described in section \ref{sec:MSBExtract}.
		\label{protocol:step8}
		\item $\user_k$ decrypts the result $res$ and sends it to $\server$
		(it will be either \textbf{Accepted} or \textbf{Rejected} by $\server$).
		$\user_k$ also runs another proof $\mathbf{ZKPCorrectDec}(res)$
		to convince $\server$ that he
		did follow the protocol honestly (Section \ref{sec:ZKPReencrypt}).\label{protocol:step9}




		%$\server$ also computes
		%the encryption of the authentication result $Enc(\Delta < \tau)$
		%using another homomorphic operation $Enc(\Delta \stackrel{?}{<}
		%\tau) \gets \textbf{EvalRes}(pk_k, \tau, Enc(\Delta))$.
		%\item $\server$ sends $Enc(\Delta \stackrel{?}{<} \tau)$ to $\user_k$.
		%$\user_k$ uses his private key $sk_k$ to decrypt the plaintext $
		%res \gets \Delta
		%\stackrel{?}{<} \tau$.



		% * <trung.dinh@monash.edu> 2016-10-21T13:15:14.957Z:
		%
		% we agreed to do this later, for now, we change back to GSW instead of BGV. Later when we apply MCC we will consider bringing these garble circuit back.
		%
		% ^.
		%\item $\server$ masks the computed distance with a random
		%value $R$, using Homomorphic addition operation:
		%$Enc(\Delta + R) \gets EvalAdd(pk_k, Enc(\Delta),
		%Enc(R))$.
		%\item $\server$ builds a garbled circuit $\textbf{GC}$ to evaluate
		%the bit value of the comparison between a plaintext $\Delta$
		%against a threshold
		%$\tau$ privately $(\Delta \stackrel{?}{<} \tau) \gets
		%\textbf{GC}(k_{\Delta + R}, k_R)$. We note that
		%$k_{\Delta + R}$ and $k_R$ are cryptographic keys input
		%to garble circuit protocol. We refer the reader to
		%section \missref{} for details of garble circuit
		%protocols.
		%\item $\server$ sends $Enc(\Delta + R)$ and $\textbf{GC}$ to $\user_k$, $\user_k$
		%uses his private key $sk_k$ to decrypt $\Delta+R$.
		%\item $\user_k$ derives $k_{\Delta + R}$ to be use as the
		%first input to $\textbf{GC}$ and $\user_k$ runs Oblivious Transfer protocol
		%$\textbf{OT}$ to obtain $k_R$ from $\server$ privately.
		%$\textbf{OT}$ is discussed in section
		%\missref{}.
		%\item $\user_k$ evaluates $(\Delta \stackrel{?}{<} \tau) \gets
		%\textbf{GC}(k_{\Delta + R}, k_R)$ and sends the result
		%$res$ to $\server$.





		%\item $\user_k$ convinces $\server$ that he did follow the
		%protocol honestly using Zero Knowledge Proof protocol
		%$\textbf{ZKP}$. This protocol is discussed in section
		%\missref{}.

	\end{enumerate}
	The proposed scheme satisfies the security notions defined in Sect. \ref{sec:syntaxModel}.
	\begin{theorem}
		\label{theo:server}
		Under the IND-CPA security of a BV cryptosystem, and the zero-knowledge
		property of the Stern protocol, the proposed scheme satisfies an (Honest But Curious) Server Privacy's Security.
	\end{theorem}
	\begin{theorem}
		\label{theo:client}
		Under the IND-CPA security of a BV cryptosystem and the soundness
		property of the underlying Stern protocol, the proposed scheme satisfies Impersonation Security. Concretely, for $\delta>0$, the protocol is $(q,c)$-secure against impersonation with $c \leq c(\delta) + 3 \cdot c_1$, assuming the underlying non-private biometric protocol has imperonsation probability $\varepsilon_{bio}$ and the underlying Stern ZK protocols have knowledge errors $\eps_{ZK1},\ldots,\eps_{ZK4}$ such that $q(\varepsilon_{ZK1}+\varepsilon_{ZK2} +
\varepsilon_{ZK3} + \varepsilon_{ZK4}) + \delta \leq c_1 \cdot \varepsilon_{bio}$, $c(\delta) = 2 e^{1+2\delta}$, and the condition $\sigma/r_0 \geq 4 \pi k n q$ holds, with $k = 1 + \sqrt{1/\pi \ln(2nq/\delta)}$ and $r_0$ being an upper bound on the size of the noise in $C_{HD}$.
	\end{theorem}

\end{description}

\begin{figure}[htbp!] 
  \centering \procedure{THE THIRD PROTOCOL}{
    \textbf{Client} \> \> \textbf{Server}\pclb
    \pcintertext[dotted]{Enrolment}\\
    \text{Extract } \mathbf{x} \randomsample D_k \> \> \\
    T_k = Enc^{(1)}(\mathbf{x},\pk) \> \sendmessageright*{(k, T_k)}
    \> \text{Persist $(k,T_{k})$}\pclb
    \pcintertext[dotted]{Authentication}\\
    \text{Extract } \mathbf{y} \randomsample D_k \> \> \\
    Q_k = Enc^{(1)}(\mathbf{y},\pk) \> \sendmessageright*{(k, Q_k)}
    \> \\
    \> \sendmessageright*{\mathbf{ZKPValidEnc}} \> C_{HD} \gets \mathbf{EvalDistance}(T_k, Q_k)\\
    \> \sendmessageleft*{C_{HD'}} \> C_{HD'} \gets Enc^{(1)}(HD,e_0) + Enc^{(1)}(r,e_r)\\
    HD' \gets Dec(C_{HD'},\sk) \> \> \\
    C_{HD'_0} \gets Enc^{(1)}(HD', 0, \dots, 0) \> \sendmessageright*{C_{HD'_0}} \> \\
    HD' = b_0 + b_1 2 + \dots + b_l 2^{l-1} \> \> \\
    C_i \gets Enc^{(1)}(b_i) \> \sendmessageright*{C_i} \> \\
    \> \sendmessageright*{\mathbf{ZKPUnpack}(C_{HD}, C_{HD'_0})} \> \\
    \> \sendmessageright*{\mathbf{ZKPBinDecomp}(C_{i}, C_{HD'_0})} \> C''_{HD} \gets Enc^{(2)}(2^t + \tau - HD)\\
    \> \sendmessageleft*{C_{res}} \> C_{res} = Enc^{(3)}(res) \gets \mathbf{MSBExtract}(C''_{HD})\\
    res = Dec(C_{res}) \> \sendmessageright*{\mathbf{ZKPCorrectDec}(res)} \>
    }
  \caption{The Third Protocol}
  \label{fig:thirdProtocol}
\end{figure}


\section{The Homomorphic tools}
\subsection{Extracting the Most Significant Bit homomorphically}
\label{sec:MSBExtract}
We observe that \(HD < \tau \iff MSB(2^{l} + \tau - HD) = 1\), where \(l\) is
the bit-length of \(HD\) and MSB denotes the Most Significant Bit. This is our
attempt to compare Hamming Distance homomorphically, the idea is to let the
server compute homomorphically the ciphertext of \(MSB(2^{l} + \tau - HD)\),
then having the client to decrypt it and to send back the authentication result
with a zero knowledge proof. This section discusses a variant of the technique
from \cite{ducas2015fhew} to efficiently compute the MSB of the plaintext $M$ given
$Enc(M)$, we adapt this technique to work with BGV encryption rather than GSW encryption used in \cite[ducas2015fhew]. The main idea comes from the way we encode the message $M$ in ``unary'' form before the
encryption.

Given $M \in \mathbb{Z}_{2n}$, we observe that
\[
  \begin{cases}
    MSB(M) = 0 \iff M \in [0, n)\\
    MSB(M) = 1 \iff M \in [n, 2n)
  \end{cases}
\]

Assume that we encrypt $M$ using the SHE scheme (section
\ref{sec:BVScheme}). With the message space $R_t$ and assuming that $2n < t < q$,
we can encode $M$ as a ring element $m \in R_t$ as follows
\[
  m(x) = 0x^0 + 0x^1 + \dots + 1x^M + \dots + 0x^{n-1}
  \ \textnormal{if} \ M \in [0,n)
\]
or, due to $x^n = -1$ in $R_q$, we can also encode M as
\[
  m(x) = 0x^0 + 0x^1 + \dots - 1x^M + \dots + 0x^{n-1}
  \ \textnormal{if} \ M \in [n,2n)
\]
The ciphertext $Enc^{(2)}(M)$ has this form
$(\mathbf{c} = \mathbf{p_0}\mathbf{u} + t\mathbf{g} + \mathbf{m}, \mathbf{c'} =
\mathbf{p_1}\mathbf{u} + t\mathbf{f})$, where $(\mathbf{p_0}, \mathbf{p_1})$ is
the public key and
$\mathbf{u}, \mathbf{f}, \mathbf{g} \randomsample \chi_{\alpha q}$.  We denote
$ rot({\textbf{c}}) \in \mathbb{Z}_q^{n\times n}$ as being an anti-circulant
square matrix, whose first column is $\mathbf{c}$, the other columns being the
cyclic rotations of $\mathbf{c}$ with the cycled entries negated
\[
  rot({\mathbf{c}})=
  \begin{bmatrix}
    c_0 & -c_{n-1} & -c_{n-2} & \dots\\
    c_1 & c_0 & -c_{n-1} & \dots\\
    \dots & \dots & \dots & \dots\\
    c_{n-1} & c_{n-2} & c_{n-3} & \dots
  \end{bmatrix}
\]
It's easy to see that $rot(\mathbf{c}\mathbf{u}) = rot(\mathbf{c})
\vec{u}$. Let $rot(\mathbf{c})[0]$ to be the first column of $rot(\mathbf{c})$.

\begin{lemma}\label{lemma:bitToBin}
	Given $M \in Z_{2n}$ and $(\mathbf{c},\mathbf{c'}) = Enc^{(2)}(M)$ as the first level ciphertext of $M$ from the BV scheme, let $\vec{1} = \{1,1,\dots,1\} \in \mathbb{Z}^n$. The transformed ciphertext $(l, l') \leftarrow (\vec{1}
	rot({\mathbf{c}})[0], \vec{1}
	rot({\mathbf{c'}})) \in (\mathbb{Z}_Q
	, \mathbb{Z}_Q^n)$ encrypts the MSB information of $M$.
\end{lemma}

\begin{algorithm}
  \caption{Most Significant bit extraction}\label{alg:MSBExtract}
  \hspace*{\algorithmicindent} \textbf{Input:} $\mathbf{c} = Enc^{(2)}(M)$ \\
  \hspace*{\algorithmicindent} \textbf{Output: $EncLWE((-1)^{MSB(M)})$} 
  \begin{algorithmic}[1]
    \Procedure{MSBExtract}{$\mathbf{c}$} 
    \State $allOne = \{1,\dots,1\}$
    \State $rot_{c_0} \gets rot(c_0)$
    \State $lwe_0 \gets allOne \cdot rot_{c_0}[0]$
    \State $rot_{c_1} \gets rot(c_1)$
    \State $lwe_1 \gets allOne \cdot rot_{c_1}$
    \State \textbf{return} $(lwe_0,lwe_1)$
    \EndProcedure
  \end{algorithmic}
\end{algorithm}


\begin{proof}
	The following is the case:\\
	\begin{align*}
	\vec{1} \cdot rot(\mathbf{c})[0] \in \zzq &= \vec{1}\overrightarrow{
		\mathbf{p_0}\mathbf{u} + t\mathbf{g} + \mathbf{m}}\\
	&= \vec{1}\cdot\overrightarrow{p_0u} +t\vec{1}\cdot\vec{g} +\vec{1}\cdot\vec{m}\\
	&= -\vec{1}(rot(p_1s)\vec{u} +t.rot(e)\vec{u}) + t\vec{1}\cdot\vec{g} + (-1)^{MSB(M)}\\
	&= -\vec{1}rot(p_1)\vec{u}\vec{s} - t.rot(e)\vec{u}\vec{s} + t\vec{1}\cdot\vec{g} + (-1)^{MSB(M)}\\
	\end{align*}
	Provided that $\mathbf{c'} = \mathbf{p_1}\mathbf{u} + t\mathbf{f}$, the decryption $\langle(l,l'),(1,\mathbf{s})\rangle \mod t$ is $\pm1$.
	This implies the MSB information of M as discussed. We use here the relation $\vec{1}\cdot \vec{m} = (-1)^{MSB(M)}$ thanks to the ``unary'' encoding of M discussed previously.
\end{proof}

\subsection{Converting from binary-encoded to unary-encoded plaintext}
\label{sec:binToUna}
This section discusses a linear transformation to map a message $b \in \{0,1\}$
onto a message $x^{jb}$ for $j \geq 1$. Let $T: cx + d = y$ be the linear transformation. We want $T$ to map $0 \rightarrow x^{j0} $ and
$1 \rightarrow x^j$, or
\[
  \begin{cases}
    c.0 + d = 1\\
    c + d = x^j
  \end{cases}
  \Leftrightarrow
  \begin{cases}
    c = x^j - 1\\
    d = 1
  \end{cases}
\]
Due to the homomorphism property of BV cryptosystems , we can apply
$T$ in the ciphertext domain to obtain $Enc(x^{jb})$ given $Enc(b)$,
for $b \in \{0,1\}$:
\begin{align}
  \label{eq:encBitConvert}
  Enc^{(2)}(j.b) = Enc^{(1)}(x^{jb}) &= Enc^{(1)}(c)Enc(b) + Enc^{(1)}(d) \nonumber \\
              &= Enc^{(1)}(x^j - 1)Enc^{(1)}(b) + Enc^{(1)}(1)
\end{align}
From the implementation point of view, this operation can be done faster
by ensuring $\mathbf{u}, \mathbf{f}, \mathbf{g} \gets 0$ instead of sampling them from
$\chi$ during $Enc(x^j -1)$ and $Enc(1)$, which results in $Enc^{(1)}(x^j -1) = (x^j - 1, 0)$ and $Enc^{(1)}(1) = (1,0)$. These are still valid encryptions and will not affect the correctness of Eq. (\ref{eq:encBitConvert}).

This submodule is used in our protocol at authentication step
\ref{protocol:step7}. Recall that the server needs to compute $Enc^{(2)}(HD')$,
which is the encryption of $HD'$ in the ``unary'' mode of encoding (the message is
encoded in the exponent instead of in the coefficient of the polynomial). Given the encryptions $Enc(b_{i})$ of the bits $b_{i}$ of $HD' = \sum_{j = 0}^{l -1} b_{j}2^{j}$
, the server can convert $Enc(b_{j})$ to $Enc(2^{i}b_{i})$
$Enc(x^{jb})$ and perform
\[
  Enc^{(2)}(HD') = Enc^{(1)}(x^{HD'}) = \prod_{i=0}^{l-1}Enc^{(1)}(x^{b_i2^i})
\]
Note that this operation involves $log(l)$ levels of homomorphic multiplication, where
$l$ is the bit length of the Hamming Distance.
\begin{algorithm}
  \caption{Binary to Unary ciphertext}\label{alg:ToUnary}
    \hspace*{\algorithmicindent} \textbf{Input:} $\mathbf{c_{i}} = Enc(b_{i})$ \\
  \hspace*{\algorithmicindent} \textbf{Output:} $HD$
  \begin{algorithmic}[1]
    \Procedure{ToUnary}{$\mathbf{c_i}$}
    \For{$i = 0, \dots, l-1$}
    \State let $j = 2^{i}$
    \State let $\mathbf{hd_i} \gets (x^j - 1,0)\times \mathbf{c_i} + (1,0)$
    \EndFor
    \State let $\mathbf{hd} \gets \mathbf{hd}_0 \times \mathbf{hd}_1 \times \dots
    \times \mathbf{hd}_{l-1}$


    \State \textbf{return} $\mathbf{hd}$
    \EndProcedure
  \end{algorithmic}
\end{algorithm}

\section{The Zero Knowledge Tools}
\label{sec:zkptools}
\subsection{ZKPoPK of Regev Cryptosystem}
\label{sec:zkpRegev}
In this section, we first review an application of the \cite{ling2013improved} technique to apply ZKPoPK on Regev Cryptosystems, then we elaborate on the variants to be used in the protocol.
Given parameters $q, m, n, t, \chi$ of a typical LWE-based cryptosystem, we can describe a variant of Regev's system as follows:
\begin{description}
\item [Kengen.] A secret key $\vec{s}$ can be chosen from $\chi^n$. The public key is then generated as
  $pk = (p_0, p_1) = (\mathbf{A}, \mathbf{A}\vec{s} + t\vec{e})$. Where $\mathbf{A} \randomsample \mathbb{Z}_q^{m \times n}$
  and $\vec{e} \randomsample \chi^n$
\item [Encrypt.] Given a message $M \in \mathbb{Z}_q$, the ciphertext $C$ is computed by first sampling a random
  vector $\vec{r} \in \chi^n$ and setting
  $C = (c_0, c_1) = (p_0\vec{r}, p_1\vec{r} + M)$
\item [Decrypt.] Given a ciphertext $C = (c_0, c_1)$, the message $M$ can be recovered by computing $M = c_1 - c_0\vec{s} \mod t$
\end{description}
In \cite{ling2013improved}, the ZKPoPK was attained by proving the encryption relation
\begin{align*}
  R_{Regev}^{q,m,n,t,\chi} = \{ ((p_0,p_1),(c_0,c_1),\vec{r}||M) \in (\mathbb{Z}_q^{m \times n} \times \mathbb{Z}_q^{m})
  \times (\mathbb{Z}_q^n \times \mathbb{Z}_q) \times \mathbb{Z}_q^{n+1} : \\
  (c_0 = p_0\vec{r}) \land (c_1 = p_1\vec{r} + M) \}
\end{align*}

Let $\mathbf{A}' = \begin{bmatrix}
  p_1, 1\\
  p_0, 0
\end{bmatrix}
$, and $\mathbf{y} = \begin{bmatrix}
  c_1\\c_0
\end{bmatrix}$ be public parameters in the proof and
let $\mathbf{x} = \begin{bmatrix}
  \vec{r}\\
  M
\end{bmatrix}$
be the $Prover$'s witness. We observe that $\mathbf{A'}\mathbf{x}= \mathbf{y} \mod q$, that is, $\mathbf{x}$ is a solution
to the ISIS problem defined by $(\mathbf{A'},\mathbf{y})$ and that we can use the \textbf{SternExt} protocol (section
\ref{append:Stern}) to obtain an efficent ZKPoPK. This works in a symmetric key setting, where the $Prover$ knows
the random $\vec{r}$ to use as his witness. In our context, the client does not know that $\vec{r}$ as encryption was
set by the server. Following the decryption equation:
\begin{align*}
  c_1 - c_0\vec{s} &= p_1\vec{r} + M - p_0\vec{r}\vec{s} \\
                   &= \mathbf{A}\vec{s}\vec{r} + t\vec{e}\vec{r} + M - \mathbf{A}\vec{r}\vec{s}\\
                   &= t\tilde{e} + M,
\end{align*}
we can write out the decryption relation as
\begin{align}
  \label{eq:RegevPub}
  R_{Regev,dec}^{q,m,n,t,\chi} = \{ ((p_0,p_1),(c_0,c_1),\vec{s},\vec{e},\tilde{e}, M) \in (\mathbb{Z}_q^{m \times n} \times \mathbb{Z}_q^{m})
  \times (\mathbb{Z}_q^n \times \mathbb{Z}_q) \times \chi^n \times \chi^n \times \chi \times \zzq :\\ \nonumber
  (p_1 = p_0\vec{s} + t\vec{e}) \land (c_1 = c_0\vec{s} + t\tilde{e} + M) \}
\end{align}
In this situation, we can let $\mathbf{A'} = \begin{bmatrix}
  c_0, t, 0 , 1 \\p_0, 0, t, 0
\end{bmatrix}
$
and $\mathbf{y} = \begin{bmatrix}
  c_1\\p_1
\end{bmatrix}$
be the public parameters and let $\mathbf{x} = \begin{bmatrix}
  \vec{s}\\ \tilde{e}\\ \vec{e}\\ M
\end{bmatrix}
$, further applying the \textbf{SternExt} to obtain the ZKPoPK  . We note that the two separate rows of $\mathbf{A'}$ prove the two
separate relations in (\ref{eq:RegevPub}): The $Prover$ needs to prove that he knows a secret $\vec{s}$ that can decrypt
$(c_0,c_1)$; he also needs to prove that the secret key $\vec{s}$ is also the one corresponding to the public key
$(p_0, p_1)$.


\subsection{ZKPoPK of BV cryptosystem}
\label{sec:ZKPBV}
In this section, we discuss ZKPoPK for a ring variant of the Regev scheme discussed above, which is the BV system that we use in
our application context (section \ref{sec:BVScheme}). We will refer to this
proof as $\mathbf{ZKPValidEnc}$. Recall that our public key is a pair of ring elements $pk = (\mathbf{p_0},
\mathbf{p_1})$, where $\mathbf{p_0}, \mathbf{p_1} \in \rrq$ and $\mathbf{p_1}\mathbf{s}+ t\mathbf{e} = -\mathbf{p_0} $. This
is one of the relation that the client will need to prove later on. Next, given a ciphertext $c = (\mathbf{c_0}, \mathbf{c_1})$, the original
plaintext $\mathbf{m} \in \rrq$ can be recovered by $\mathbf{m} = \mathbf{c_0} + \mathbf{c_1}\mathbf{s} \mod t$ (spelled out as $\mathbf{c_1}\mathbf{s} + \mathbf{c_0} = \mathbf{m} + t\mathbf{e'}$, or $\mathbf{c_1}\mathbf{s} -t\mathbf{e'} -\mathbf{m} = -\mathbf{c_0}$).
In summary, the relation required for the ZKPoPK is:
\begin{align}
  \label{eq:BVRel}
  R_{BV}^{Q,n,t,\chi} = \{((\mathbf{c_0}, \mathbf{c_1}),(\mathbf{p_0}, \mathbf{p_1}), \mathbf{s},\mathbf{e'}, \mathbf{e}, \mathbf{m} \in
  (\rrq \times \rrq) \times (\rrq \times \rrq)  \times \chi^n \times \chi^n \times \chi^n \times R_t:\\ \nonumber
  (\mathbf{p_1}\mathbf{s} + t\mathbf{e} = -\mathbf{p_0} ) \land (\mathbf{c_1}\mathbf{s} - t\mathbf{e'} -\mathbf{m} = -\mathbf{c_0})
  \}
\end{align}
We can proceed in a way similar to what appears in section \ref{sec:zkpRegev}, where we tried to derive the ISIS relation ($\mathbf{A}\mathbf{x} = \mathbf{y} \mod q$)
from the above relation and obtain the ZKP accordingly.
The matrix $\mathbf{A}$ should be derived from $\mathbf{T}= \begin{bmatrix}
  \mathbf{c_1}, -t, 0, -1\\ \mathbf{p_1}, 0, t, 0
\end{bmatrix}$ in order to obtain (\ref{eq:BVRel}). Note that with $\mathbf{c_1},\mathbf{p_1} \in \rrq$, we can construct $\mathbf{A}$ by
replacing from $\mathbf{T}$: $\mathbf{c_1}$ and $\mathbf{p_1}$ are replaced by $rot(\mathbf{c_1})$ and $rot(\mathbf{p_1})$, constants
are replaced by the product of the themselves by the identity matrix $\mathbf{I}$. Recall that $ rot({\textbf{c}}) \in
\mathbb{Z}_q^{n\times n}$ is defined to be an anti-circulant
square matrix, whose first
column is $\mathbf{c}$, the other columns being the cyclic rotations of
$\mathbf{c}$ with the cycled entries negated
\[
  rot({\mathbf{c}})=
  \begin{bmatrix}
    c_0 & -c_{n-1} & -c_{n-2} & \dots\\
    c_1 & c_0 & -c_{n-1} & \dots\\
    \dots & \dots & \dots & \dots\\
    c_{n-1} & c_{n-2} & c_{n-3} & \dots
  \end{bmatrix}
\]
So, the matrix $\mathbf{A}$ is of the following form:
\begin{align}
  \label{matrix:ZKP}
  \begin{bmatrix}
    \SquareBox[draw=black, minimum size=35]{$rot(\mathbf{c_1})$}
    \SquareBox[draw=black, minimum size=35]{$-t\mathbf{I}$}
    \SquareBox[draw=black, minimum size=35]{$\mathbf{0}$}
    \SquareBox[draw=black, minimum size=35]{$\mathbf{-I}$}\\
    \SquareBox[draw=black, minimum size=35]{$rot(\mathbf{p_1})$}
    \SquareBox[draw=black, minimum size=35]{$\mathbf{0}$}
    \SquareBox[draw=black, minimum size=35]{$t\mathbf{I}$}
    \SquareBox[draw=black, minimum size=35]{$\mathbf{0}$}
  \end{bmatrix}
\end{align}

By constructing the matrix $\mathbf{A}$ this way, we can let $\mathbf{x} = \begin{bmatrix}
  \mathbf{s}\\\mathbf{e'}\\\mathbf{e}\\\mathbf{m}
\end{bmatrix}$,  $\mathbf{y} = \begin{bmatrix}
  -\mathbf{c_0}\\-\mathbf{p_0}
\end{bmatrix}$ and come up with the original ISIS relation $\mathbf{A}\mathbf{x} = \mathbf{y} \mod Q$. Again,
we can use the \textbf{SternExt} protocol (section \ref{append:Stern}) to obtain the ZKPoPK with $\mathbf{x}$ being
the $Prover$'s witness and $\mathbf{A}, \mathbf{y}$ being the public parameters (Algorithm \ref{alg:ZKPBV}).

\begin{algorithm}
  \caption{ZKPoPK for BV}\label{alg:ZKPBV}
  \begin{algorithmic}[1]
    \Procedure{ZKPBV}{$(\mathbf{c}, pk),(\mathbf{m, s, e, e'}))$}
    \State $rot_{c_1} \gets rot(\mathbf{c_1})$
    \State $rot_{p_1} \gets rot(\mathbf{pk_1})$
    \State let I be the $n \times n$ identity matrix
    \State let Z be the $n \times n $ zero matrix
    \State $\mathbf{A} \gets ((rot_{c_1},-tI, Z, -I),(rot_{p_1}, Z, tI,Z)) $
    \State $\mathbf{x} \gets (\mathbf{s, e', e, m})$
    \State $\mathbf{y} \gets (\mathbf{-c_0, -pk_0})$
    \State \textbf{Return} $\mathbf{SternExt(A,x,y)}$
    \EndProcedure
  \end{algorithmic}
\end{algorithm}


\subsection{ZKP of plaintext with zero coefficients}
This section extends the previous proof with several submodules. Firstly, we
need a proof to convince the server that our ciphertext encrypts the message of the form $\mathbf{m(x)} =
0 + m_1x^1 + m_2x^2 + \dots + m_{n-1}x^{n-1}$. Next, we need another proof to convince about the knowledge of encryption of
$\mathbf{m(x)} = m_0 + 0x^1 + 0x^2 + \dots + 0x^{n-1}$. We also use some other proofs for messages containing only 1s or 0s. In other words, we want the $Prover$ to convince the $Verifier$
about the format correctness of the plaintext, in addition to asserting  knowledge of the plaintext itself.

\begin{description}
\item[Proving $\mathbf{m}=\sum_{i = 0}^l(m_ix^i) \land m_0 = 0$ \textbf{(ZKPExt1)}.]
  If and only if the $Prover$ P has the message $\mathbf{m}$ in this format, he can compute:
  \begin{align*}
    rot(\mathbf{c_0})\mathbf{s} -t\mathbf{Ie'} - \begin{bmatrix}
      1\\
      0\\
      \dots\\
      0
    \end{bmatrix}\mathbf{m_0} &= -\mathbf{c_0}\\
    \iff rot(\mathbf{c_0})\mathbf{s} -t\mathbf{Ie'} - \begin{bmatrix}
      m_0\\
      0\\
      \dots\\
      0
    \end{bmatrix} &= -\mathbf{c_0}
  \end{align*}
  In order to set up this proof, we can proceed similarly to what was proposed in section \ref{sec:ZKPBV},
  just a minor modification is needed in the matrix represented in (\ref{matrix:ZKP}):
  We completely remove all the last $(n-1)$ columns of the last $n$ columns during the construction of the matrix $\mathbf{A}$ (the new $\mathbf{A}$ will thus have dimension $n \times (3n + 1)$ instead of
  $n \times 4n$). The specification is summarized in Algorithm (\ref{alg:ZKPExt1}).

  \begin{algorithm}
    \caption{ZKP for zero constant coefficient}\label{alg:ZKPExt1}
    \begin{algorithmic}[1]
      \Procedure{ZKPExt1}{$(\mathbf{c}, pk),(\mathbf{m, s, e, e'}))$}
      \State $rot_{c_1} \gets rot(\mathbf{c_1})$
      \State $rot_{p_1} \gets rot(\mathbf{pk_1})$
      \State let I be the $n \times n$ identity matrix
      \State let I' be 1 column matrix with all 1s.
      \State let Z be the $n \times n $ zero matrix
      \State let Z' be 1 column matrix with all 0s.
      \State $\mathbf{A} \gets ((rot_{c_1},-tI, Z, -I'),(rot_{p_1}, Z, tI,Z')) $
      \State $\mathbf{x} \gets (\mathbf{s, e', e, m})$
      \State $\mathbf{y} \gets (\mathbf{-c_0, -pk_0})$
      \State \textbf{Return} $\mathbf{SternExt(A,x,y)}$
      \EndProcedure
    \end{algorithmic}
  \end{algorithm}

\item[Proving $\mathbf{m}=\sum_{i = 0}^l(m_ix^i) \land m_j = 0\  for\  j = 1,2
  \dots l-1$. \textbf{(ZKPExt2)}] This proof can be engineered similarly to $\mathbf{ZKPExt1}$, following
  the same method. Except that in this one, instead of removing $(n-1)$ columns, we
  remove only the first column of the last $n$ columns of $\mathbf{A}$. The result
  is the matrix $\mathbf{A}$, with dimension $n \times (4n-1)$. The specification is summarized in Algorithm (\ref{alg:ZKPExt2}).
  \begin{algorithm}
    \caption{ZKP for only constant coefficient}\label{alg:ZKPExt2}
    \begin{algorithmic}[1]
      \Procedure{ZKPExt2}{$(\mathbf{c}, pk),(\mathbf{m, s, e, e'}))$}
      \State $rot_{c_1} \gets rot(\mathbf{c_1})$
      \State $rot_{p_1} \gets rot(\mathbf{pk_1})$
      \State let I be the $n \times n$ identity matrix
      \State let I' be I with the first column removed.
      \State let Z be the $n \times n $ zero matrix
      \State let Z' be Z with the first column removed.
      \State $\mathbf{A} \gets ((rot_{c_1},-tI, Z, -I'),(rot_{p_1}, Z, tI,Z')) $
      \State $\mathbf{x} \gets (\mathbf{s, e', e, m})$
      \State $\mathbf{y} \gets (\mathbf{-c_0, -pk_0})$
      \State \textbf{Return} $\mathbf{SternExt(A,x,y)}$
      \EndProcedure
    \end{algorithmic}
  \end{algorithm}


\item[Proving $\mathbf{m}=\sum_{i = 0}^l(m_ix^i) \land m_j = 0 \lor m_j = 1\  for \  j = 0,1
  \dots l-1$ \textbf{(ZKPExt3 and ZKPExt4)}. ] Following the previous extensions, proving that a message
  contains only zero or one coefficients amounts to a trivial by modification of the matrix $\mathbf{A}$ and an according set up of the bound of
  \textbf{SternExt}.
\end{description}

\subsection{ZKP of re-encryption correctness}
\label{sec:ZKPReencrypt}
This section first discusses the module \textbf{ZKPUnpack(c, c')}, which proves the
correctness of the re-encryption of a single slot unpacked plaintext $\mathbf{m'} = Dec(\mathbf{c'})$ from the
coefficients-packed ciphertext $\mathbf{m} = Dec(\mathbf{c})$.
We then provide details about the $\mathbf{ZKPBinDecomp(c,c_i)}$ module, aimed at proving the correctness of re-encryption of a binary-encoded plaintext as a unary-encoded one.
\begin{description}
\item [{ZKPUnpack(c,c).}]The relation of the proof is:
  \[
    R_{\mathbf{ZKPUnpack}} = \{ \mathbf{c, c'} \in R_q \times R_q :
    \mathbf{m} = Dec(\mathbf{c}) \land \mathbf{m'} = Dec(\mathbf{c'}) \land m_0
    = m_0' \land (m_i' = 0 \  \forall i \neq 0)\}
  \]
  Given $m_0 = m_0'$, we observe $\mathbf{m(x) - m'(x)} = 0 + m''_1x + \dots + m''_{n-1}x^{n-1}$. Therefore, $\mathbf{ZKPUnpack}$
  can be carried out as specified in Algorithm (\ref{alg:ZKPUnpack})

  \begin{algorithm}
    \caption{ZKP of coefficients transform}\label{alg:ZKPUnpack}
    \begin{algorithmic}[1]
      \Procedure{ZKPUnpack}{$\mathbf{c, c'}$}
      \State Let $b_1 \gets \mathbf{ZKPExt1((c-c',pk),(Dec(c-c'), s, e, e'))}$
      \State Let $b_2 \gets \mathbf{ZKPExt2((c',pk),(Dec(c'),s,e,e'))}$
      \State \textbf{Return} $b_1 \land b_2$
      \EndProcedure
    \end{algorithmic}
  \end{algorithm}

\item [$\mathbf{ZKPBinDecomp(c,c_i).}$] The relation of the proof is:
  \[
    R_{\mathbf{ZKPBinDec}} = \{ \mathbf{c,c_i} \in R_q \times R_q^l:
    \mathbf{m} = Dec(\mathbf{c}) \land \mathbf{m_0} = \sum_{i=0}^{l-1}b_i2^i
    \land \mathbf{c_i} = Enc(b_i)
    \}
  \]
  The specification of the proof is detailed in Algorithm
  (\ref{alg:ZKPBinDecomp}).

  \begin{algorithm}
    \caption{ZKP of encoding transform}\label{alg:ZKPBinDecomp}
    \begin{algorithmic}[1]
      \Procedure{ZKPBinDecomp}{$\mathbf{c, c_i}$}
      \State Let $\mathbf{c'} \gets \sum_{i=0}^{l-1}\mathbf{c_i}2^i$
      \State Let $\mathbf{c''} \gets c - c' $
      \State \textbf{Return} $\mathbf{ZKPExt1((c'',pk),(Dec(c''),s,e,e'))}$
      \EndProcedure
    \end{algorithmic}
  \end{algorithm}
\item [Applications in our protocol.] In authentication step \ref{protocol:step5}, after receiving
  the ciphertext $C_{HD'}$, which encrypts a plaintext
  of the form $(HD', g_1, \dots, g_{n-1})$, $\user_k$ removes the noise terms $g_1, \dots,
  g_{n-1}$ and sends the re-encryption $C_{HD_0'} = Enc(HD', 0, 0, \dots,
  0)$ back to $\server$. The client needs to prove that he performs this step correctly, this is done
  by $\mathbf{ZKPUnpack(C_{HD},C_{HD_0'}})$. In this step, the server also receives $\mathbf{c_i} = Enc(b_i)$ to compute $Enc(x^{HD'})$, as discussed in section \ref{sec:binToUna}. Before doing this operation, the client needs to convince the server
  that the bits sent are actually the ones decomposed from $HD'$. This proof is done
  by $\mathbf{ZKPBinDecomp(C_{HD_0'},c_i)}$.

  Besides, In authentication step \ref{protocol:step1}, $\user_k$ uses $\mathbf{ZKPBV}$ to convince $\server$ that he is
  authenticating with a valid template $Y$. Moreover, in step \ref{protocol:step9}, $\user_k$ can use either $\mathbf{ZKPExt3}$ or $\mathbf{ZKPExt4}$ to
  convince $\server$ about the authentication result.
\end{description}

\section{Security Proofs}
\label{append:Proofs}
\subsection{Security Proof for Theorem~\ref{theo:client}: Type I Impersionation attack}
The proof of theorem \ref{theo:server} and \ref{theo:client} can be provided
using a sequence of games between the challenger $\challenger$ and the adversary
$\attacker$. We present a sequence of games as well as the relations among them to demonstrate the type I security model proof.\\
% \begin{figure}[htbp!] 
%   \centering
%   \fbox{
%    \begin{gameproof}[nr=-1]
%   \gameprocedure[linenumbering, mode=text]{
%     $D_{k} \randomsample D_{bio}$\\
%     $(\sk, \pk) \gets KeyGen(params)$\\
%     $\mathbf{X}_{k} \randomsample D_{k}$\\
%     $\enc{\mathbf{X_{k}}} \gets Enc(\mathbf{X}_{k},\pk)$\\
%     For $i=1,\dots,q$:\\
%     $\mathbf{Y}_{i} \gets \{0,1\}^{n}$\\
%     $\enc{\mathbf{Y}_{i}} \gets Enc(\mathbf{Y}_{i},\pk)$\\
%     $verifierView1 \gets \mathbf{ZKPoPK1}((\sk,\mathbf{Y}_{i});(\pk,\enc{\mathbf{Y}_{i}}))$\\
%     $\enc{\mathbf{HD}_{i}} = EvalDistance(\enc{\mathbf{X}_{k}},\enc{\mathbf{Y}_{i}})$\\
%     $r_{i} \randomsample \mathbb{Z}_{HD}$,$\enc{\mathbf{HD'}_{i}} = Add(\enc{\mathbf{HD}_{i}},\enc{r_{i}})$\\
%     $HD'_{i} \gets Dec(\enc{\mathbf{HD'}_{i}},\sk)$\\
%     $verifierView2 \gets \mathbf{ZKPoPK2}((\sk,\mathbf{HD'}_{i});(\pk,\enc{\mathbf{HD'}_{i}}))$\\
%     $HD_{i} \gets HD'_{i} - r_{i}$\\
%     $res_{i} \gets compare(HD_{i}, \tau)$\\
%     $\beta \gets \adv(verifierView1, verifierView2, \enc{\mathbf{X}_{k}}, \enc{\mathbf{Y}_{i}}, res_{i}, r_{i}, HD_{i},
%     \enc{\mathbf{HD'}_{i}}, \enc{\mathbf{HD}_{i}})$ }
% \end{gameproof}
%   }
%   \caption{Game 0 - Malicious Client game}
%   \label{fig:game0protocol3client}
% \end{figure}
\textit{Game 0} Game 0 is the original impersonation game for type I attack.
\begin{description}
	\item [Setup.] $\challenger$ intiates $D_k \randomsample D_{bio}$ and $X_k
	\randomsample D_k$. $\challenger$ sets up $(sk_k, pk_k)$ and executes
	$Enrol(k, X_k)$ to get $(sk_k, T_k =(pk_k, C_k = Enc^{(1)}_{pk_k}(X_k)))$.
	$\attacker$ submits the attack query type I and receives $sk_k$ from
	$\challenger$.
	\item [Query.] $\attacker$ runs $q$ authentication sessions. In each session $j
	= 1, \dots, q$,
	$\attacker$ sends $(Q_k^{(j)} = Enc^{(1)}(Y^{(j)}))$. $\attacker$ and
	$\challenger$ runs $\mathbf{ZKPValidEnc}(Q_k^{(j)},Y^{(j)})$. $\challenger$ evaluates
	$C_{HD} = \mathbf{EvalDistance}_{pk_k}(C_k, Q_k^{(j)})$, then computes
	$C_{HD'} = (-1)C_{HD} + Enc_{pk_k}^{(1)}(r_{HD'},e_{HD'})$ for $r_{HD'}
	\randomsample \mathcal{P}$ and $e_{HD'} \randomsample \chi_{HD}$. The
	result ciphertext is sent to $\attacker$, $\attacker$ decrypts $C_{HD'}$
	and decomposes it into bits and further sends back the ciphertexts $C_0^{(j)}, \dots,
	C_{l-1}^{(j)} (= Enc^{(1)}(b_i), i = 0,\dots, l-1)$, as well as the
	re-encryption $C_{HD_0'}$. $\attacker$ and $\challenger$ engage
	$\mathbf{ZKPUnpack}(C_{HD},C_{HD_0'})$ and $\mathbf{ZKPBinDecomp}(C_{HD_0'},
	C_i^{(j)})$.
	$\challenger$ evaluates $C_{HD}'' = Enc^{(2)}(2^l + t) +
	\mathbf{ToUnary}(C_i^{(j)}) + Enc^{(2)}(-r) $ to get $Enc^{(2)}(2^l + t -
	HD)$. $\challenger$ computes $Enc^{(3)}(res) \gets
	\mathbf{MSBExtract}(C_{HD}'')$ and sends the result to $\attacker$. $\attacker$
	decrypts it and sends the authentication result bit back. $\challenger$ and
	$\attacker$ then fire $\mathbf{ZKPCorrectDec}(res)$ to trigger the server's acceptance of the
	authentication result. At the end, the server outputs \textbf{Accept} if
	all the proofs pass and $res = \mathbf{Accept}$.
\end{description}
Next, we discuss the games that follow, the plan being to proceed towards the final game where 
everything $\attacker$ receives relating to $X_k$ can be simulated
without any knowledge about $X_k$, except that $X_k$ is
the function $Verify(X_k, Y)$. Let $res_s = Verify(X_k, Y^{(j)})$ and $S_i$ be
the event in the game $i$ such that $res_s = Accept$.\\
\textit{Game 1}. In this game, we abort $\mathbf{ZKPValidEnc}$ if $Q_k^{(j)}$
is not a valid encryption of the query, but the $Prover$ manages to pass the
proof. Let $(*)_1$ be this event.
\[
(*_1)res_s = \begin{cases}
\text{Reject if } \mathbf{ZKPValidEnc} \text{ fails}\\
\text{res else}
\end{cases}
\]
Let $bad_0$ be the event in game 0 : $\exists j \leq q\  s.t\  (*_1)\
\textnormal{is thus the case}$. We want to show that when we modify \textit{game 0}, the
probability of a successful forgery $S_1$ in this \textit{game 1} is not much
lower than what it was. Due to the modification, we observe that
$
Pr[S_1] \geq Pr[S_0] - Pr[bad_0]
$
.For any $j$ in the $q$ authentication attemps, by the $\varepsilon-soundness$ property of
$\mathbf{ZKPValidEnc}$ as a proof of membership in (*), we have $Pr[(*_1)\
occurring\ for\ some \ j] \leq \varepsilon_{ZK1}$. So, the probability of $bad_0$
would be the union of these events, which is bounded by $Pr[bad_0] \leq
q\varepsilon_{ZK1}$. In other words, the advantage of $\attacker$ in \textit{game
	1} is
\[
Pr[S_1] \geq Pr[S_0] - Pr[bad_0] \geq \varepsilon_{imp} - q\varepsilon_{ZK1}
\]
\\
\textit{Game 2}. In this game, we abort $\mathbf{ZKPUnpack}$ if, in one of the
$j^{th}$ runs, the $Verifier$ accepts but the ciphertext does not satisfy the
relation. Let $bad_1$ be this event, by the same type of argument, we can
derive $Pr[bad_1] \leq q\varepsilon_{ZK2}$ and therefore
$$Pr[S_2] \geq Pr[S_1]
- Pr[bad_1] \geq \varepsilon_{imp} - q(\varepsilon_{ZK1}+\varepsilon_{ZK2})
$$
\textit{Game 3 and Game 4}. Similarly, we abort $\mathbf{ZKPBinDecomp}$ and
$\mathbf{ZKPCorrectDec}$ if, in any $j^{th}$ runs, the $Verifier$ accepts even
when the correctness of the ZKP is not satisfied. We have
$$Pr[S_3] \geq  \varepsilon_{imp} - q(\varepsilon_{ZK1}+\varepsilon_{ZK2}
+\varepsilon_{ZK3})
$$ and
$$Pr[S_4] \geq  \varepsilon_{imp} - q(\varepsilon_{ZK1}+\varepsilon_{ZK2} +
\varepsilon_{ZK3} + \varepsilon_{ZK4})
$$
By the end of \textit{Game 4}, if in any authentication attempt $j$, there is
no abort while running any of the 4 games, then, by the correctness property of ZKP, the
server output is equal to the output of $Verify(X_k, Y^{(j)})$. In other words,
we have shown what we could get by just querying the oracle $Verify()$. Next,
we want to simulate everything related to $X_k$ the attacker can see using
just that oracle.\\
\textit{Game 5.} At the end of \textit{Game 4}, $\challenger$ possesses the bit
$b = Verify(Y^{(i)},X_k)$. In this game, we can change $C_{res}^{(j)}$ from
$\mathbf{MSBExtract}(C_{HD}'') = Enc(b;e_{res})$ to
$Enc(verify(Y^{(i)},X_k);e_{res})$, given that the challenger can use the
secret key to extract $e_{res}$. Despite this change,  
the same ciphertext is still accessible to $\attacker$, so its probability of winning of 
is the same as in \textit{Game 4}.\\
\textit{Game 6.} In this game, we change the way $\challenger$ computes
$C_{HD}''$: In the orignal game 0, $Enc(-r)$ was added to remove the mask. We now
want to remove this $r$ from being used anywhere in the game, so we replace
this with $Enc(0)$. This change does not affect $\attacker$'s success
probability: $r$ only affects the plaintext inside $C_{HD}''$, since we do not
use this plaintext anymore (as it has been replaced in \textit{Game 5}), so this change
does not affect the information available to the attacker. Again, $Pr[S_6] = Pr[S_5] = Pr[S_4]$.\\
\textit{Game 7.} We modify the way $C_{HD}'$ is computed in this game. Instead
of calculating $C_{HD}' \gets (-1)C_{HD} + Enc(r;e_{HD'})$, the challenger chooses a
random $HD' \randomsample \mathbb{Z}_p$ and encrypts it with the noise used
before: $C_{HD}' \gets Enc(HD'; -e_{HD} + e_{HD'})$. In this game, the
plaintext has changed from being $r + HD$ to a uniform $HD' \in \mathbb{Z}_p$.
Since $r$ is also uniform in $\mathbb{Z}_p$, the attacker is confronted with a uniform
plaintext in both cases. Therefore, $Pr[S_7] = Pr[S_6]$.\\
\textit{Game 8.} Finally, we set $C_{HD'} = Enc(HD', e_{HD'})$ for $e_{HD'}
\randomsample \chi_{mask}$ instead of $-e_{HD} + e_{HD'}$. We replace the sum
of the Gaussian noise with a random noise. In Section \ref{sec:Renyi}, we
showed that $Pr[S_8] \geq \frac{1}{c(\delta)}(Pr[S_7]-q \cdot \delta)$, where $c(\delta) = RD(-e_{HD} + e_{HD'},
e_{HD}) \leq 2 \cdot e^{1+2\delta}$ by Lemma~\ref{le:Renyi} and by our assumption on the parameter's values. After we finish \textit{Game 8}, we notice that all the messages available to the attacker can be simulated with only the verified bit $b =
Verify(Y^{(i)}, X_k)$. We now have an attacker $A'$ against the biometric
impersonation with advantage:
\[
\varepsilon_{bio} = Adv(A') = Pr[S_8] \geq \frac{1}{c(\delta)}(\varepsilon_{imp} - q(\varepsilon_{ZK1}+\varepsilon_{ZK2} +
\varepsilon_{ZK3} + \varepsilon_{ZK4}) + \delta),
\]
which gives the claimed bound $\varepsilon_{imp} \leq c(\delta) \cdot \varepsilon_{bio} + q \cdot (\varepsilon_{ZK1}+\varepsilon_{ZK2} +
\varepsilon_{ZK3} + \varepsilon_{ZK4}) + \delta \leq (c(\delta)+c_1) \cdot \varepsilon_{bio}$ if $q(\varepsilon_{ZK1}+\varepsilon_{ZK2} +
\varepsilon_{ZK3} + \varepsilon_{ZK4}) + \delta \leq c_1 \cdot \varepsilon_{bio}$.


\subsection{Security Proof for Theorem~\ref{theo:client}: Type II Impersionation attack}
\label{append:ProofsTypeII}
The proof of Theorem \ref{theo:client} can be provided using a sequence of games between the challenger $\challenger$ and the adversary $\attacker$. We present
a sequence of games as well as the relations among them to demonstrate the type II security model proof. The idea is that in this type of attack, $sk_k$ is not used to compute the view of $\attacker$. On the other hand, the soundess of the zero-knowledge proof of knowledge $\mathbf{ZKPValidEnc}$ implies the existence of an efficient witness extractor algorithm, that can be used to extract the witness (i.e. the secret key $sk_k$) from a cheating prover succeeding with probability non-negligibly higher than the knowledge error of the zero-knowledge proof, thus contradicting the IND-CPA security of the BV encryption scheme. \\\\
\textit{Game 0}. Game 0 is the original impersonation game for a type II attack, i.e., the same as Game 0 in the proof of security against Type I attacks, except that $(T_k =(pk_k, C_k = Enc^{(1)}_{pk_k}(X_k)))$ is given by $\challenger$ to $\attacker$ at the beginning of the game, rather than $sk_k$.
For $j \in \{1,\ldots,q\}$, let $res^{j}$ denote the result of the $j$th authentication protocol run between $\attacker$ and $\challenger$, and $S_0$ be
the event in the game $0$ such that $res^{j} = Accept$ for some $j=1,\ldots,q$. We have $\Pr[S_0] = \varepsilon_{imp,II}$ as the type II success probability of $\attacker$. \\\\
\textit{Game 1}. From the definition of event $S_0$ in Game 0, it follows that there exists some $j^* \in \{1,\ldots,q\}$ such that $\Pr[res^{j^*} = Accept] \geq \varepsilon_{imp,II}/q$. Furthermore, by an averaging argument, there must exist a set $G$ of $(D_k,X_k,pk_k)$ such that $\Pr[(D_k,X_k,pk_k) \in G] \geq \varepsilon_{imp,II}/(2 \cdot q)$, and for each $(D'_k,X'_k,pk'_k) \in G$, we have $\Pr[res^{j^*} = Accept |(D_k,X_k,pk_k)=(D'_k,X'_k,pk'_k)] \geq  \varepsilon_{imp,II}/(2 \cdot q)$. By $\varepsilon_{ZK1}$-soundness of the zero-knowledge proof of knowledge $\mathbf{ZKPValidEnc}$ (cite Golderich's `Foundations of Cryptography' book, volume 1, Prop. 4.7.5), there exists a witness extractor algorithm that runs in expected time $T'=O(\mathrm{poly}(n \log Q) \cdot T / (\varepsilon_{imp,II}/(2*q) - \varepsilon_{ZK1}))$, where $T$ denotes the run-time of $\attacker$ and outputs a witness containing $sk_k$ for ${ZKPValidEnc}$. Therefore, we obtain a (secret key recovery) attack algorithm against the IND-CPA security of the BV encryption scheme, with expected run-time $T'$ and advantage $\varepsilon' \geq \varepsilon_{imp,II}/(2 \cdot q)$. Hence,  if $\varepsilon_{imp,II}/(2*q) - \varepsilon_{ZK1} > \varepsilon_{imp,II}/(4*q)$, or equivalently, if $\varepsilon_{imp,II} > 2 \cdot q \varepsilon_{ZK1}$, we obtain a contradiction with the assumption the BV encryption scheme with parameters $Q,n,\sigma$ is IND-CPA against attacks with expected time $O(\mathrm{poly}(n \log Q) \cdot T / \varepsilon_{ZK1})$ and advantage $\geq \varepsilon_{ZK1}$. It follows under the latter assumption that $\varepsilon_{imp,II} \leq 2q \varepsilon_{ZK1} \leq 2 c_1  \cdot \varepsilon_{bio}$, under the assumption that  $q(\varepsilon_{ZK1}+\varepsilon_{ZK2} +
\varepsilon_{ZK3} + \varepsilon_{ZK4} + \delta) \leq c_1 \cdot \varepsilon_{subsection}$.


\subsection{Security Proof for Theorem~\ref{theo:server}: Privacy against Server}
\label{append:ProofsPrivacy}
The proof of Theorem \ref{theo:client} can be done using a sequence of games between the challenger $\challenger$ and the adversary $\attacker$. We present a sequence of games. The idea is to proceed to remove $sk_k$ and $X_k$ from being used to compute the view of $\attacker$, except for $Verify(X_k,Y_k^{j})$ queries, as in the ideal game, relying on the correctness of the protocol and the IND-CPA security of the BV encryption scheme. \\\\
\textit{Game 0}. Game 0 is the original real privacy game, in which $(T_k =(pk_k, C_k = Enc^{(1)}_{pk_k}(X_k)))$ is given by $\challenger$ to $\attacker$ at the beginning of the game. Then, for $j=1\ldots,q$, the attacker sends $Y_k^{(j)} \in \{0,1\}^n$ to $\challenger$, and the latter simulates a run of the authentication protocol between an honest client with input $(k,Y_k^{(j)}, sk_k)$ and an honest server with input $(k,T_k)$, returning to $\attacker$ the protocol view $V^{(j)}_S$ of the server. Finally, $\attacker$ outputs a bit $\beta$. In the following Game $i$, we let $S_i$ denote the event of $\beta=1$.\\\\
\textit{Game 1}. We change the computation of the authentication result bit $res^{(j)}$ sent by client to server from the decryption of the ciphertext $\textbf{MSBExtract}(C''_{HD}$ (its value in Game 0) to the result returned by $Verify(X_k, Y^{(j)})$. By correctness of the protocol, this does not change the value of $res^{(j)}$, so $\Pr[S_1] = \Pr[S_0]$. \\\\
\textit{Game 2}. We change the computation of the zero-knowledge protocol transcripts. Instead of computing those transcripts using the secret witnesses, we simulate them using the statistical zero-knowledge simulator algorithms for the zero-knowledge proofs. By the zero-knowledge property, this is a perfect simulation, yielding $\Pr[S_2]= \Pr[S_1]$.\\\\
\textit{Game 3}. We change the computation of the ciphertexts $C^{(j)}_i$ for $i=0,\ldots,l-1$ and $Q^{(j)}_k$ for $j=1,\ldots,q$ and $C_k$ to encrypt zero messages, instead of encrypting the secret-related messages as in the previous game. Since now $sk_k$ is not used anywhere in generating the view of $\attacker$, it follows by a hybrid argument that $|\Pr[S_3]-\Pr[S_2]| ((l+1) \cdot q + 1) \cdot \varepsilon_{BV}$, where $\varepsilon_{BV}$ denotes the maximal advantage of an attacker against IND-CPA of BV scheme against attacks with run-time $T + \mathrm{poly}(n, \log Q)$, where $T$ is the run-time of $\attacker$.
In this game, since the only information on $X_k$ comes via the $Verify(X_k,Y_k^{j})$ queries, the challenger together with $\attacker$ constitute an efficient attacker against the ideal privacy game, which outputs 1 with probability different by at most $(l+1) \cdot q + 1) \cdot \varepsilon_{BV}$ relatively to the probability of outputting 1 in the real privacy game, as required.

\section{Evaluations and Improvements}
\label{sec:evaluation}


\subsection{Combination of ZKP}
\label{sec:combination-zkp}
A $\sum-$protocol can be composed together to construct more complex relations.
There are several forms of decomposition such as AND, OR, NEQ, etc.  We describe
some forms of composition of the \(\sum-protocol\) that are used in our own protocol:
AND-composition, OR-composition. We first describe the generic \(\sum-\)protocol
and its combinations. The BV-ZKP (Figure \ref{fig:belhamoudaProtocol}) protocol
is an instance of such a protocol and the technique can be applied inherently.
\begin{description}
\item[$\sum-$protocol] The protocol is a generic 3-moves transaction between 2 parties
  \(Prover\) and \(Verifier\), it is used to prove (supporting zero-knowledge) a
  relation \(R(x,w)\), where \(x\) is the public parameter known by both
  parties and \(w\) is a witness known by the \(Prover\) only. The protocol's
  view is a set of 3 messages (Figure \ref{fig:sigmaProtocol}): the commitment
  \(c\) is a function of a random factor \(\rho\), the challenge \(ch\) is
  normally random, and the response \(r\) is a function computed from
  \(x, w, \rho, ch\). There are 2 extra algorithms for the \(\sum-\)protocol: a
  \(verify(r,ch,c)\) algorithm used by the \(Verifier\) in the last step to
  check the correctness of the proof result, and a simulator \(sim\), taking
  \(x\) and a random parameter \(\rho'\) as inputs, and and outputting a view
  \(\bar{c},\bar{ch},\bar{r}\) that is indistinguishable from the genuine view
  of the protocol.

  \begin{figure}[htbp!] 
    \centering \procedure{Sigma Protocol}{
      \textbf{Prover} \> \> \textbf{Verifier}\\
      \rho \randomsample random \> \> \\
      c \gets comm(\rho) \> \> \\
      \> \sendmessageright*{c} \> \\
      \> \> ch \randomsample random \\
      \> \sendmessageleft*{ch} \> \\
      r \gets resp(\rho,w,x,ch) \> \> \\
      \> \sendmessageright*{r} \> \\
      \> \> verify(r, ch, c)\\
    }
    \caption{Sigma Protocol}
    \label{fig:sigmaProtocol}
  \end{figure}
  % \begin{figure}[h!]
  %   \centering
  %   \begin{equation*}
  %     \begin{array}{c c c}
  %       \text{\textbf{Prover}} & & \text{\textbf{Verifier}} \\
  %       \\
  %       \rho \randomsample random & & \\
  %       c = comm(\rho) & & \\
  %                              & \xrightarrow{c} & \\
  %                              & & ch \randomsample random \\
  %                              & \xleftarrow{ch} & \\
  %       r = resp(\rho,w,x,ch) & & \\
  %                              & \xrightarrow{r} & \\
  %                              & & verify(r, ch, c)\\
  %     \end{array}
  %   \end{equation*}
  %   \caption{Sigma Protocol}
  %   \label{fig:sigmaProtocol}
  % \end{figure}
\end{description}


\begin{description}
\item[AND-COMPOSITION] Given two relations $R_1 = \left\{ (v_1,w_1) \right\}$
  and $R_2 = \left\{ (v_2, w_2) \right\}$ with the same challenge space, a
  $\sum$-Protocol of
  $R_1 \wedge R_2 = \left\{ (v_1, v_2, w_1, w_2): (v_1;w_1) \in R_1, (v_2,w_2)
    \in R_2\right\}$ can be obtained by running a $\sum$-Protocol for $R_1$ and
  a $\sum$-Protocol for $R_2$ in parallel, using a \emph{common} challenge.
  Figure \ref{fig:belhamoudaProtocolAND} is a concrete example combining 2 ZKP for BV.
  

\item[OR-Compostion] In this composition, given the $\sum-protocol$ for many  
  relations $R_{1}$,$R_{2}$,\dots,\(R_{n}\) the goal is to construct a protocol for the
  relation
  $R_{OR}(\vec{x}, w_{i}) $, where \(\exists i \leq n: R(x_{i},w_{i}) = 1\). The main reason behind this composition is that the verifier
  can let the prover use the simulator of the \(\sum-protocol\) for the
  relations \(R_{j}\), for which the prover does not know the witness.
  The verifier provides a single challenge \(c\)
  such that the prover can split that into challenges \(c_{1}, c_{2}, \dots, c_{n}\)
  provided that \(c_{i}\) satisfies a linear constraint in terms of \(c\),
  for example \(c = c_{1} \xor c_{2} \xor \dots \xor c_{n}\). The final OR-combination proof is
  obtained by composing one run of the \(\sum-protocol\) with other runs of the
  simulators for the \(\sum-protocol\). (Figure \ref{fig:OR-Combination})

  \begin{figure}[htbp!] 
    \centering \procedure{OR Composition of ZKP}{
      \textbf{Prover} \> \> \textbf{Verifier}\\
      \rho_{i} \randomsample random \> \> \\
      c_{i} = comm(\rho_{i}) \> \> \\
      \text{For } j = 1,\dots,n \wedge j \neq i: \> \> \\
      \text{    } \rho_{j} \randomsample random; \> \> \\
      \text{    } (c_{j}, ch_{j}, r_{j}) \gets ZKPSim(\rho_{j}, x_{j}) \> \> \\
      \> \sendmessageright*{ch_j,c_{1}, c_{2}, \dots, c_{n}} \> \\
      \> \> ch \randomsample \mathbb{Z}_{n} \\
      \> \sendmessageleft*{ch} \> \\
      ch_{i} = ch - \sum_{j \neq i}{ch_{j}} \> \> \\
      r_{i} = resp(\rho_{i}, w_{i}, x_{i}, ch_{i}) \> \> \\
      \> \sendmessageright*{r_{1}, r_{2}, \dots, r_{n}} \> \\
      \> \> \forall i \in [n], ver(r_{i}, ch_{i}, c_{i}) = 1 \\
      \> \> ch = \sum_{i \in [n]}ch_{i}\\
    }
    \caption{OR Composition of ZKP}
    \label{fig:OR-Composition}
  \end{figure}
  % \begin{figure}[h!]
  %   \centering
  %   \begin{equation*}
  %     \begin{array}{c c c}
  %       \text{\textbf{Prover}} & & \text{\textbf{Verifier}} \\
  %       \\
  %       \rho_{i} \randomsample random & & \\
  %       c_{i} = comm(\rho_{i}) & & \\
  %       \text{For } j = 1,\dots,n \wedge j \neq i: & & \\
  %       \text{    } \rho_{j} \randomsample random; & & \\
  %       \text{    } (c_{j}, ch_{j}, r_{j}) \gets ZKPSim(\rho_{j}, x_{j}) & & \\
  %                              & \xrightarrow[ch_{j}]{c_{1}, c_{2}, \dots, c_{n}} & \\
  %                              & & ch \randomsample \mathbb{Z}_{n} \\
  %                              & \xleftarrow{ch} & \\
  %       ch_{i} = ch - \sum_{j \neq i}{ch_{j}} & & \\
  %       r_{i} = resp(\rho_{i}, w_{i}, x_{i}, ch_{i}) & & \\
  %                              & \xrightarrow{r_{1}, r_{2}, \dots, r_{n}} & \\
  %                              & & \forall i \in [n], ver(r_{i}, ch_{i}, c_{i}) = 1 \\
  %                              & & ch = \sum_{i \in [n]}ch_{i}\\
  %     \end{array}
  %   \end{equation*}
  %   \caption{}
  %   \label{fig:OR-Combination}
  % \end{figure}
\end{description}



\section{Evaluation and Results}
\label{sec:5results}


\label{sec:5combineZKP}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../thesis"
%%% End:
