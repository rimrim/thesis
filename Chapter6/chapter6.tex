\chapter{The third protocol - Computing and Comparing HD Homomorphically}
\label{chap:thirdProtocol}

% **************************** Define Graphics Path **************************
\ifpdf
\graphicspath{{Chapter5/Figs/Raster/}{Chapter5/Figs/PDF/}{Chapter5/Figs/}}
\else
\graphicspath{{Chapter5/Figs/Vector/}{Chapter5/Figs/}}
\fi

% **** main chapter

\section{Introduction}
\label{sub:introChap3}
In the previous chapter, we assumed that, given the Hamming Distance (HD) between two
binary bitstring templates, it is infeasible for an attacker to infer or acquire any information
about the original templates stored on the server. This assumption is plausible as long as the
distributions of the registered and the queried templates are not in any way
correlated (analysing these distributions is out of scope of the
project). However, in this chapter, we introduce our first attempt to hide 
information from the server as well. Our results not only cause the protocol
to work regardless of the aforementioned dependencies, it is also the first step we take to
secure the authentication protocol against an \textit{active} server security model. Although the communication size of this variant might not
be suitable in practice for current network infrastructures, one can
still find some generic techniques used within it to be helpful while
applying them to balance the computation time and the communication size of
lattice-based cryptographic protocols. The contributions of this variant include:
\begin{itemize}
\item A technique to compare Hamming Distance (HD) homomorphically by computing
  the Most Significant Bit (MSB) of a specific ciphertext.
\item A packing methods conversion technique to transform a ciphertext
  encrypting a binary-encoded to a unary-encoded plaintext.
\item Some extensions of the Zero Knowledge Proof (ZKP) technique we used
  in previous chapter to check the format of a message, in addition to the
  information carried by the plaintext itself.
\item The combination of ZKP protocols to balance the communication size
  trade-offs when used with lattice-based cryptosystems.
\end{itemize}

\section{The Homomorphic tools}
\subsection{Extracting the Most Significant Bit homomorphically}
\label{sec:MSBExtract}
We observe that \(HD < \tau \iff MSB(2^{l} + \tau - HD) = 1\), where \(l\) is
the bit-length of \(HD\) and MSB denotes the Most Significant Bit. This is our
attempt to compare Hamming Distance homomorphically, the idea is to let the
server compute homomorphically the ciphertext of \(MSB(2^{l} + \tau - HD)\),
then having the client to decrypt it and to send back the authentication result with a zero knowledge proof. This section discusses a variant of the technique from
\cite{ducas2015fhew} to compute the MSB of the plaintext $M$ given $Enc(M)$. The
technique is used in \ref{protocol:step8}. The main idea comes from the way we
encode the message $M$ before the encryption.

Given $M \in \mathbb{Z}_{2n}$, we observe that
\[
  \begin{cases}
    MSB(M) = 0 \iff M \in [0, n)\\
    MSB(M) = 1 \iff M \in [n, 2n)
  \end{cases}
\]

Assume that we encrypt $M$ using the SHE scheme (section
\ref{sec:BVScheme}). With the message space $R_t$ and assuming that $2n < t < q$,
we can encode $M$ as a ring element $m \in R_t$ as follows
\[
  m(x) = 0x^0 + 0x^1 + \dots + 1x^M + \dots + 0x^{n-1}
  \ \textnormal{if} \ M \in [0,d)
\]
or, due to $x^n = -1$ in $R_q$, we can also encode M as
\[
  m(x) = 0x^0 + 0x^1 + \dots - 1x^M + \dots + 0x^{n-1}
  \ \textnormal{if} \ M \in [n,2n)
\]
The ciphertext $Enc(M)$ has this form
$(\mathbf{c} = \mathbf{p_0}\mathbf{u} + t\mathbf{g} + \mathbf{m}, \mathbf{c'} =
\mathbf{p_1}\mathbf{u} + t\mathbf{f})$, where $(\mathbf{p_0}, \mathbf{p_1})$ is
the public key and $\mathbf{u}, \mathbf{f}, \mathbf{g} \randomsample \chi$.  We
denote $ rot({\textbf{c}}) \in \mathbb{Z}_q^{n\times n}$ as being an anti-circulant
square matrix, whose first column is $\mathbf{c}$, the other columns being the
cyclic rotations of $\mathbf{c}$ with the cycled entries negated
\[
  rot({\mathbf{c}})=
  \begin{bmatrix}
    c_0 & -c_{n-1} & -c_{n-2} & \dots\\
    c_1 & c_0 & -c_{n-1} & \dots\\
    \dots & \dots & \dots & \dots\\
    c_{n-1} & c_{n-2} & c_{n-3} & \dots
  \end{bmatrix}
\]
It's easy to see that $rot(\mathbf{c}\mathbf{u}) = rot(\mathbf{c})
\vec{u}$.

\begin{lemma}\label{lemma:bitToBin}
	Given $M \in Z_{2n}$ and $(\mathbf{c},\mathbf{c'}) = Enc(M)$ as the first level ciphertext of $M$ from the BV scheme, let $\vec{1} = \{1,1,\dots,1\} \in \mathbb{Z}^n$. The transformed ciphertext $(l, l') \leftarrow (\vec{1}
	rot({\mathbf{c}})[0], \vec{1}
	rot({\mathbf{c'}})) \in (\mathbb{Z}_Q
	, \mathbb{Z}_Q^n)$ encrypts the MSB information of $M$.
\end{lemma}

\begin{algorithm}
  \caption{Most Significant bit extraction}\label{alg:MSBExtract}
  \begin{algorithmic}[1]
    \Procedure{MSBExtract}{$\mathbf{c}$}
    \State $allOne = \{1,\dots,1\}$
    \State $rot_{c_0} \gets rot(c_0)$
    \State $lwe_0 \gets allOne \times rot_{c_0}[0]$
    \State $rot_{c_1} \gets rot(c_1)$
    \State $lwe_1 \gets allOne \times rot_{c_1}$
    \State \textbf{return} $(lwe_0,lwe_1)$
    \EndProcedure
  \end{algorithmic}
\end{algorithm}


\subsection{Proof of lemma \ref{lemma:bitToBin}}
\label{append:proofHom}
 \begin{proof}
	The following is the case:\\
	\begin{align*}
	\vec{1}rot(\mathbf{c})[0] \in \zzq &= \vec{1}\overrightarrow{
		\mathbf{p_0}\mathbf{u} + t\mathbf{g} + \mathbf{m}}\\
	&= \vec{1}\overrightarrow{p_0u} +t\vec{1}\vec{g} +\vec{1}\vec{m}\\
	&= -\vec{1}(rot(p_1s)\vec{u} +t.rot(e)\vec{u}) + t\vec{1}\vec{g} \pm1\\
	&= -\vec{1}rot(p_1)\vec{u}\vec{s} - t.rot(e)\vec{u}\vec{s} + t\vec{1}\vec{g} \pm1\\
	\end{align*}
	Provided that $\mathbf{c'} = \mathbf{p_1}\mathbf{u} + t\mathbf{f}$, the decryption $\langle(l,l'),(1,\mathbf{s})\rangle \mod t$ is $\pm1$.
	This implies the MSB information of M as discussed.
\end{proof}

\subsection{Converting from binary-encoded to unary-encoded plaintext}
\label{sec:binToUna}
This section discusses a linear transformation to map a message $b \in \{0,1\}$
onto a message $x^{jb}$ for $j \geq 1$. Let $T: cx + d = y$ be the linear transformation. We want $T$ to map $0 \rightarrow x^{j0} $ and
$1 \rightarrow x^j$, or
\[
  \begin{cases}
    c.0 + d = 1\\
    c + d = x^j
  \end{cases}
  \Leftrightarrow
  \begin{cases}
    c = x^j - 1\\
    d = 1
  \end{cases}
\]
Due to the homomorphism property of BV cryptosystems , we can apply
$T$ in the ciphertext domain to obtain $Enc(x^{jb})$ given $Enc(b)$,
for $b \in \{0,1\}$:
\begin{align}
  \label{eq:encBitConvert}
  Enc(x^{jb}) &= Enc(c)Enc(b) + Enc(d) \nonumber \\
              &= Enc(x^j - 1)Enc(b) + Enc(1)
\end{align}
From the implementation point of view, this operation can be done faster
by ensuring $\mathbf{u}, \mathbf{f}, \mathbf{g} \gets 0$ instead of sampling them from
$\chi$ during $Enc(x^j -1)$ and $Enc(1)$, which results in $Enc(x^j -1) = (x^j - 1, 0)$ and $Enc(1) = (1,0)$. These are still valid encryptions and will not affect the correctness of Eq. (\ref{eq:encBitConvert}).

This submodule is used in our protocol at \ref{protocol:step7}. Recall that the server needs
to compute $Enc^{(2)}(HD')$, which is the encryption of $HD'$ in the second mode
of encoding (the message is encoded in the exponent instead of in the coefficient of the
polynomial). Given $HD' = \sum_{i=0}^{l-1}b_i2^i$ and $Enc(b_i)$, the server can convert them to $Enc(x^{jb})$ and perform
\[
  Enc^{(2)}(x^{HD'}) = \prod_{i=0}^{l-1}Enc^{(2)}(x^{b_i2^i})
\]
Note that this operation involves $log(l)$ levels of homomorphic multiplication, where
$l$ is the bit length of the Hamming Distance.
\begin{algorithm}
  \caption{Binary to Unary ciphertext}\label{alg:ToUnary}
  \begin{algorithmic}[1]
    \Procedure{ToUnary}{$\mathbf{c_i}$}
    \For{$j = 0, \dots, l-1$}
    \State let $\mathbf{hd_j} \gets (x^j - 1,0)\times \mathbf{c_j} + (1,0)$
    \EndFor
    \State let $\mathbf{hd} \gets \mathbf{hd_0} \times \mathbf{hd_1} \times \dots
    \times \mathbf{hd_{l-1}}$


    \State \textbf{return} $\mathbf{hd}$
    \EndProcedure
  \end{algorithmic}
\end{algorithm}

\section{The Zero Knowledge Tools}
\label{sec:zkptools}
\subsection{ZKPoPK of Regev Cryptosystem}
\label{sec:zkpRegev}
In this section, we first review an application of the \cite{ling2013improved} technique to apply ZKPoPK on Regev Cryptosystems, then we elaborate on the variants to be used in the protocol.
Given parameters $q, m, n, t, \chi$ of a typical LWE-based cryptosystem, we can describe a variant of Regev's system as follows:
\begin{description}
\item [Kengen.] A secret key $\vec{s}$ can be chosen from $\chi^n$. The public key is then generated as
  $pk = (p_0, p_1) = (\mathbf{A}, \mathbf{A}\vec{s} + t\vec{e})$. Where $\mathbf{A} \randomsample \mathbb{Z}_q^{m \times n}$
  and $\vec{e} \randomsample \chi^n$
\item [Encrypt.] Given a message $M \in \mathbb{Z}_q$, the ciphertext $C$ is computed by first sampling a random
  vector $\vec{r} \in \chi^n$ and setting
  $C = (c_0, c_1) = (p_0\vec{r}, p_1\vec{r} + M)$
\item [Decrypt.] Given a ciphertext $C = (c_0, c_1)$, the message $M$ can be recovered by computing $M = c_1 - c_0\vec{s} \mod t$
\end{description}
In \cite{ling2013improved}, the ZKPoPK was attained by proving the encryption relation
\begin{align*}
  R_{Regev}^{q,m,n,t,\chi} = \{ ((p_0,p_1),(c_0,c_1),\vec{r}||M) \in (\mathbb{Z}_q^{m \times n} \times \mathbb{Z}_q^{m})
  \times (\mathbb{Z}_q^n \times \mathbb{Z}_q) \times \mathbb{Z}_q^{n+1} : \\
  (c_0 = p_0\vec{r}) \land (c_1 = p_1\vec{r} + M) \}
\end{align*}

Let $\mathbf{A}' = \begin{bmatrix}
  p_1, 1\\
  p_0, 0
\end{bmatrix}
$, and $\mathbf{y} = \begin{bmatrix}
  c_1\\c_0
\end{bmatrix}$ be public parameters in the proof and
let $\mathbf{x} = \begin{bmatrix}
  \vec{r}\\
  M
\end{bmatrix}$
be the $Prover$'s witness. We observe that $\mathbf{A'}\mathbf{x}= \mathbf{y} \mod q$, that is, $\mathbf{x}$ is a solution
to the ISIS problem defined by $(\mathbf{A'},\mathbf{y})$ and that we can use the \textbf{SternExt} protocol (section
\ref{sec:zkpisis}) to obtain an efficent ZKPoPK. This works in a symmetric key setting, where the $Prover$ knows
the random $\vec{r}$ to use as his witness. In our context, the client does not know that $\vec{r}$ as encryption was
set by the server. Following the decryption equation:
\begin{align*}
  c_1 - c_0\vec{s} &= p_1\vec{r} + M - p_0\vec{r}\vec{s} \\
                   &= \mathbf{A}\vec{s}\vec{r} + t\vec{e}\vec{r} + M - \mathbf{A}\vec{r}\vec{s}\\
                   &= t\tilde{e} + M,
\end{align*}
we can write out the decryption relation as
\begin{align}
  \label{eq:RegevPub}
  R_{Regev,dec}^{q,m,n,t,\chi} = \{ ((p_0,p_1),(c_0,c_1),\vec{s},\vec{e},\tilde{e}, M) \in (\mathbb{Z}_q^{m \times n} \times \mathbb{Z}_q^{m})
  \times (\mathbb{Z}_q^n \times \mathbb{Z}_q) \times \chi^n \times \chi^n \times \chi \times \zzq :\\ \nonumber
  (p_1 = p_0\vec{s} + t\vec{e}) \land (c_1 = c_0\vec{s} + t\tilde{e} + M) \}
\end{align}
In this situation, we can let $\mathbf{A'} = \begin{bmatrix}
  c_0, t, 0 , 1 \\p_0, 0, t, 0
\end{bmatrix}
$
and $\mathbf{y} = \begin{bmatrix}
  c_1\\p_1
\end{bmatrix}$
be the public parameters and let $\mathbf{x} = \begin{bmatrix}
  \vec{s}\\ \tilde{e}\\ \vec{e}\\ M
\end{bmatrix}
$, further applying the \textbf{SternExt} to obtain the ZKPoPK  . We note that the two separate rows of $\mathbf{A'}$ prove the two
separate relations in (\ref{eq:RegevPub}): The $Prover$ needs to prove that he knows a secret $\vec{s}$ that can decrypt
$(c_0,c_1)$; he also needs to prove that the secret key $\vec{s}$ is also the one corresponding to the public key
$(p_0, p_1)$.


\subsection{ZKPoPK of BV cryptosystem}
\label{sec:ZKPBV}
In this section, we discuss ZKPoPK for a ring variant of the Regev scheme discussed above, which is the BV system that we use in
our application context (section \ref{sec:BVScheme}). We will refer to this
proof as $\mathbf{ZKPValidEnc}$. Recall that our public key is a pair of ring elements $pk = (\mathbf{p_0},
\mathbf{p_1})$, where $\mathbf{p_0}, \mathbf{p_1} \in \rrq$ and $\mathbf{p_1}\mathbf{s}+ t\mathbf{e} = -\mathbf{p_0} $. This
is one of the relation that the client will need to prove later on. Next, given a ciphertext $c = (\mathbf{c_0}, \mathbf{c_1})$, the original
plaintext $\mathbf{m} \in \rrq$ can be recovered by $\mathbf{m} = \mathbf{c_0} + \mathbf{c_1}\mathbf{s} \mod t$ (spelled out as $\mathbf{c_1}\mathbf{s} + \mathbf{c_0} = \mathbf{m} + t\mathbf{e'}$, or $\mathbf{c_1}\mathbf{s} -t\mathbf{e'} -\mathbf{m} = -\mathbf{c_0}$).
In summary, the relation required for the ZKPoPK is:
\begin{align}
  \label{eq:BVRel}
  R_{BV}^{Q,n,t,\chi} = \{((\mathbf{c_0}, \mathbf{c_1}),(\mathbf{p_0}, \mathbf{p_1}), \mathbf{s},\mathbf{e'}, \mathbf{e}, \mathbf{m} \in
  (\rrq \times \rrq) \times (\rrq \times \rrq)  \times \chi^n \times \chi^n \times \chi^n \times R_t:\\ \nonumber
  (\mathbf{p_1}\mathbf{s} + t\mathbf{e} = -\mathbf{p_0} ) \land (\mathbf{c_1}\mathbf{s} - t\mathbf{e'} -\mathbf{m} = -\mathbf{c_0})
  \}
\end{align}
We can proceed in a way similar to what appears in section \ref{sec:zkpRegev}, where we tried to derive the ISIS relation ($\mathbf{A}\mathbf{x} = \mathbf{y} \mod q$)
from the above relation and obtain the ZKP accordingly.
The matrix $\mathbf{A}$ should be derived from $\mathbf{T}= \begin{bmatrix}
  \mathbf{c_1}, -t, 0, -1\\ \mathbf{p_1}, 0, t, 0
\end{bmatrix}$ in order to obtain (\ref{eq:BVRel}). Note that with $\mathbf{c_1},\mathbf{p_1} \in \rrq$, we can construct $\mathbf{A}$ by
replacing from $\mathbf{T}$: $\mathbf{c_1}$ and $\mathbf{p_1}$ are replaced by $rot(\mathbf{c_1})$ and $rot(\mathbf{p_1})$, constants
are replaced by the product of the themselves by the identity matrix $\mathbf{I}$. Recall that $ rot({\textbf{c}}) \in
\mathbb{Z}_q^{n\times n}$ is defined to be an anti-circulant
square matrix, whose first
column is $\mathbf{c}$, the other columns being the cyclic rotations of
$\mathbf{c}$ with the cycled entries negated
\[
  rot({\mathbf{c}})=
  \begin{bmatrix}
    c_0 & -c_{n-1} & -c_{n-2} & \dots\\
    c_1 & c_0 & -c_{n-1} & \dots\\
    \dots & \dots & \dots & \dots\\
    c_{n-1} & c_{n-2} & c_{n-3} & \dots
  \end{bmatrix}
\]
So, the matrix $\mathbf{A}$ is of the following form:
\begin{align}
  \label{matrix:ZKP}
  \begin{bmatrix}
    \SquareBox[draw=black, minimum size=35]{$rot(\mathbf{c_1})$}
    \SquareBox[draw=black, minimum size=35]{$-t\mathbf{I}$}
    \SquareBox[draw=black, minimum size=35]{$\mathbf{0}$}
    \SquareBox[draw=black, minimum size=35]{$\mathbf{-I}$}\\
    \SquareBox[draw=black, minimum size=35]{$rot(\mathbf{p_1})$}
    \SquareBox[draw=black, minimum size=35]{$\mathbf{0}$}
    \SquareBox[draw=black, minimum size=35]{$t\mathbf{I}$}
    \SquareBox[draw=black, minimum size=35]{$\mathbf{0}$}
  \end{bmatrix}
\end{align}

By constructing the matrix $\mathbf{A}$ this way, we can let $\mathbf{x} = \begin{bmatrix}
  \mathbf{s}\\\mathbf{e'}\\\mathbf{e}\\\mathbf{m}
\end{bmatrix}$,  $\mathbf{y} = \begin{bmatrix}
  -\mathbf{c_0}\\-\mathbf{p_0}
\end{bmatrix}$ and come up with the original ISIS relation $\mathbf{A}\mathbf{x} = \mathbf{y} \mod Q$. Again,
we can use the \textbf{SternExt} protocol (section \ref{sec:zkpisis}) to obtain the ZKPoPK with $\mathbf{x}$ being
the $Prover$'s witness and $\mathbf{A}, \mathbf{y}$ being the public parameters (Algorithm \ref{alg:ZKPBV}).

\begin{algorithm}
  \caption{ZKPoPK for BV}\label{alg:ZKPBV}
  \begin{algorithmic}[1]
    \Procedure{ZKPBV}{$(\mathbf{c}, pk),(\mathbf{m, s, e, e'}))$}
    \State $rot_{c_1} \gets rot(\mathbf{c_1})$
    \State $rot_{p_1} \gets rot(\mathbf{pk_1})$
    \State let I be the $n \times n$ identity matrix
    \State let Z be the $n \times n $ zero matrix
    \State $\mathbf{A} \gets ((rot_{c_1},-tI, Z, -I),(rot_{p_1}, Z, tI,Z)) $
    \State $\mathbf{x} \gets (\mathbf{s, e', e, m})$
    \State $\mathbf{y} \gets (\mathbf{-c_0, -pk_0})$
    \State \textbf{Return} $\mathbf{SternExt(A,x,y)}$
    \EndProcedure
  \end{algorithmic}
\end{algorithm}


\subsection{ZKP of plaintext with zero coefficients}
This section extends the previous proof with several submodules. Firstly, we
need a proof to convince the server that our ciphertext encrypts the message of the form $\mathbf{m(x)} =
0 + m_1x^1 + m_2x^2 + \dots + m_{n-1}x^{n-1}$. Next, we need another proof to convince about the knowledge of encryption of
$\mathbf{m(x)} = m_0 + 0x^1 + 0x^2 + \dots + 0x^{n-1}$. We also use some other proofs for messages containing only 1s or 0s. In other words, we want the $Prover$ to convince the $Verifier$
about the format correctness of the plaintext, in addition to asserting  knowledge of the plaintext itself.

\begin{description}
\item[Proving $\mathbf{m}=\sum_{i = 0}^l(m_ix^i) \land m_0 = 0$ \textbf{(ZKPExt1)}.]
  If and only if the $Prover$ P has the message $\mathbf{m}$ in this format, he can compute:
  \begin{align*}
    rot(\mathbf{c_0})\mathbf{s} -t\mathbf{Ie'} - \begin{bmatrix}
      1\\
      0\\
      \dots\\
      0
    \end{bmatrix}\mathbf{m_0} &= -\mathbf{c_0}\\
    \iff rot(\mathbf{c_0})\mathbf{s} -t\mathbf{Ie'} - \begin{bmatrix}
      m_0\\
      0\\
      \dots\\
      0
    \end{bmatrix} &= -\mathbf{c_0}
  \end{align*}
  In order to set up this proof, we can proceed similarly to what was proposed in section \ref{sec:ZKPBV},
  just a minor modification is needed in the matrix represented in (\ref{matrix:ZKP}):
  We completely remove all the last $(n-1)$ columns of the last $n$ columns during the construction of the matrix $\mathbf{A}$ (the new $\mathbf{A}$ will thus have dimension $n \times (3n + 1)$ instead of
  $n \times 4n$). The specification is summarized in Algorithm (\ref{alg:ZKPExt1}).

  \begin{algorithm}
    \caption{ZKP for zero constant coefficient}\label{alg:ZKPExt1}
    \begin{algorithmic}[1]
      \Procedure{ZKPExt1}{$(\mathbf{c}, pk),(\mathbf{m, s, e, e'}))$}
      \State $rot_{c_1} \gets rot(\mathbf{c_1})$
      \State $rot_{p_1} \gets rot(\mathbf{pk_1})$
      \State let I be the $n \times n$ identity matrix
      \State let I' be 1 column matrix with all 1s.
      \State let Z be the $n \times n $ zero matrix
      \State let Z' be 1 column matrix with all 0s.
      \State $\mathbf{A} \gets ((rot_{c_1},-tI, Z, -I'),(rot_{p_1}, Z, tI,Z')) $
      \State $\mathbf{x} \gets (\mathbf{s, e', e, m})$
      \State $\mathbf{y} \gets (\mathbf{-c_0, -pk_0})$
      \State \textbf{Return} $\mathbf{SternExt(A,x,y)}$
      \EndProcedure
    \end{algorithmic}
  \end{algorithm}

\item[Proving $\mathbf{m}=\sum_{i = 0}^l(m_ix^i) \land m_j = 0\  for\  j = 1,2
  \dots l-1$. \textbf{(ZKPExt2)}] This proof can be engineered similarly to $\mathbf{ZKPExt1}$, following
  the same method. Except that in this one, instead of removing $(n-1)$ columns, we
  remove only the first column of the last $n$ columns of $\mathbf{A}$. The result
  is the matrix $\mathbf{A}$, with dimension $n \times (4n-1)$. The specification is summarized in Algorithm (\ref{alg:ZKPExt2}).
  \begin{algorithm}
    \caption{ZKP for only constant coefficient}\label{alg:ZKPExt2}
    \begin{algorithmic}[1]
      \Procedure{ZKPExt2}{$(\mathbf{c}, pk),(\mathbf{m, s, e, e'}))$}
      \State $rot_{c_1} \gets rot(\mathbf{c_1})$
      \State $rot_{p_1} \gets rot(\mathbf{pk_1})$
      \State let I be the $n \times n$ identity matrix
      \State let I' be I with the first column removed.
      \State let Z be the $n \times n $ zero matrix
      \State let Z' be Z with the first column removed.
      \State $\mathbf{A} \gets ((rot_{c_1},-tI, Z, -I'),(rot_{p_1}, Z, tI,Z')) $
      \State $\mathbf{x} \gets (\mathbf{s, e', e, m})$
      \State $\mathbf{y} \gets (\mathbf{-c_0, -pk_0})$
      \State \textbf{Return} $\mathbf{SternExt(A,x,y)}$
      \EndProcedure
    \end{algorithmic}
  \end{algorithm}


\item[Proving $\mathbf{m}=\sum_{i = 0}^l(m_ix^i) \land m_j = 0 \lor m_j = 1\  for \  j = 0,1
  \dots l-1$ \textbf{(ZKPExt3 and ZKPExt4)}. ] Following the previous extensions, proving that a message
  contains only zero or one coefficients amounts to a trivial by modification of the matrix $\mathbf{A}$ and an according set up of the bound of
  \textbf{SternExt}.
\end{description}

\subsection{ZKP of re-encryption correctness}
\label{sec:ZKPReencrypt}
This section first discusses the module \textbf{ZKPUnpack(c, c')}, which proves the
correctness of the re-encryption of a single slot unpacked plaintext $\mathbf{m'} = Dec(\mathbf{c'})$ from the
coefficients-packed ciphertext $\mathbf{m} = Dec(\mathbf{c})$.
We then provide details about the $\mathbf{ZKPBinDecomp(c,c_i)}$ module, aimed at proving the correctness of re-encryption of a binary-encoded plaintext as a unary-encoded one.
\begin{description}
\item [{ZKPUnpack(c,c).}]The relation of the proof is:
  \[
    R_{\mathbf{ZKPUnpack}} = \{ \mathbf{c, c'} \in R_q \times R_q :
    \mathbf{m} = Dec(\mathbf{c}) \land \mathbf{m'} = Dec(\mathbf{c'}) \land m_0
    = m_0' \land (m_i' = 0 \  \forall i \neq 0)\}
  \]
  Given $m_0 = m_0'$, we observe $\mathbf{m(x) - m'(x)} = 0 + m''_1x + \dots + m''_{n-1}x^{n-1}$. Therefore, $\mathbf{ZKPUnpack}$
  can be carried out as specified in Algorithm (\ref{alg:ZKPUnpack})

  \begin{algorithm}
    \caption{ZKP of coefficients transform}\label{alg:ZKPUnpack}
    \begin{algorithmic}[1]
      \Procedure{ZKPUnpack}{$\mathbf{c, c'}$}
      \State Let $b_1 \gets \mathbf{ZKPExt1((c-c',pk),(Dec(c-c'), s, e, e'))}$
      \State Let $b_2 \gets \mathbf{ZKPExt2((c',pk),(Dec(c'),s,e,e'))}$
      \State \textbf{Return} $b_1 \land b_2$
      \EndProcedure
    \end{algorithmic}
  \end{algorithm}

\item [$\mathbf{ZKPBinDecomp(c,c_i).}$] The relation of the proof is:
  \[
    R_{\mathbf{ZKPBinDec}} = \{ \mathbf{c,c_i} \in R_q \times R_q^l:
    \mathbf{m} = Dec(\mathbf{c}) \land \mathbf{m_0} = \sum_{i=0}^{l-1}b_i2^i
    \land \mathbf{c_i} = Enc(b_i)
    \}
  \]
  The specification of the proof is detailed in Algorithm
  (\ref{alg:ZKPBinDecomp}).

  \begin{algorithm}
    \caption{ZKP of encoding transform}\label{alg:ZKPBinDecomp}
    \begin{algorithmic}[1]
      \Procedure{ZKPBinDecomp}{$\mathbf{c, c_i}$}
      \State Let $\mathbf{c'} \gets \sum_{i=0}^{l-1}\mathbf{c_i}2^i$
      \State Let $\mathbf{c''} \gets c - c' $
      \State \textbf{Return} $\mathbf{ZKPExt1((c'',pk),(Dec(c''),s,e,e'))}$
      \EndProcedure
    \end{algorithmic}
  \end{algorithm}
\item [Applications in our protocol.] In \ref{protocol:step5}, after receiving
  the ciphertext $C_{HD'}$, which encrypts a plaintext
  of the form $(HD', g_1, \dots, g_{n-1})$, $\user_k$ removes the noise terms $g_1, \dots,
  g_{n-1}$ and sends the re-encryption $C_{HD_0'} = Enc(HD', 0, 0, \dots,
  0)$ back to $\server$. The client needs to prove that he performs this step correctly, this is done
  by $\mathbf{ZKPUnpack(C_{HD},C_{HD_0'}})$. In this step, the server also receives $\mathbf{c_i} = Enc(b_i)$ to compute $Enc(x^{HD'})$, as discussed in section \ref{sec:binToUna}. Before doing this operation, the client needs to convince the server
  that the bits sent are actually the ones decomposed from $HD'$. This proof is done
  by $\mathbf{ZKPBinDecomp(C_{HD_0'},c_i)}$.

  Besides, In \ref{protocol:step1}, $\user_k$ uses $\mathbf{ZKPBV}$ to convince $\server$ that he is
  authenticating with a valid template $Y$. Moreover, in \ref{protocol:step9}, $\user_k$ can use either $\mathbf{ZKPExt3}$ or $\mathbf{ZKPExt4}$ to
  convince $\server$ about the authentication result.
\end{description}

\subsection{Schnorr-based ZKP technique}
\label{sec:zero-knowledge-proof}

\begin{theorem}
  Figure (\ref{fig:belhamoudaProtocol}) is a $\sum'$-Protocol for the following
  relations:
  \begin{equation}
    \label{equ:zkp_relation1}
    \begin{multlined}
      \mathcal{R} = \{ \left( \mathbf{c_0,c_1,p_0,p1},t \right), (\mathbf{m,
        s, e, e_0}): \mathbf{c_0 = -c_1s} + t\mathbf{e} +
      \mathbf{m}
      \wedge \mathbf{p_0 = -p_1s} - t\mathbf{e_{0}} \\
      \wedge \norminf{\mathbf{m}} \leq t
      \wedge \norm{\mathbf{e}} \leq \beta \wedge
      \norm{\mathbf{s}},\norm{\mathbf{e_0}} \leq \beta_0 \}
    \end{multlined}
  \end{equation}

  \begin{equation}
    \label{eq:zkp_relation2}
    \begin{multlined}
      \mathcal{R'} = \{ \left( \mathbf{c_0,c_1,p_0,p1},t \right), (\mathbf{m,
        s, e, e_0}): \mathbf{2c_0 = -2c_1s} + 2t\mathbf{e} + 2\mathbf{m} \wedge
      \mathbf{2p_0 = -2p_1s} - 2t\mathbf{e_{0}} \\
      \wedge
      \norminf{\mathbf{2m}} \leq 2t
      \wedge \norm{\mathbf{2e}} \leq 2\beta \wedge
      \norm{\mathbf{2s}},\norm{\mathbf{2e_0}} \leq 2\beta_0 \}
    \end{multlined}
  \end{equation}


  The protocol has a knowledge error of $\frac{1}{2n}$ and a completeness
  error of $1 - \frac{1}{M}$.

  \label{theo:BVZKPBenhamouda}
\end{theorem}

\begin{proof}
  We prove the properties specified in Definition \ref{def:zkp-sum-protocol}.
  \begin{description}
  \item[Completeness.] If the Prover $P$ sends a response, the following becomes the case:
    \begin{align*}
      -\mathbf{c_1s_s} + t\mathbf{s_e} + \mathbf{s_m} &= -\mathbf{c_1(r_s +
                                                        x^cs)} + t(\mathbf{r_e + x^ce}) + \mathbf{r_m + x^cm} \\
                                                      &= \mathbf{x^c}(-\mathbf{c_1s} +t\mathbf{e} + \mathbf{m})
                                                        -\mathbf{c_1r_s} + t\mathbf{r_e} + \mathbf{r_m}\\
                                                      &=\mathbf{x^cc_0} + \mathbf{t_c}
    \end{align*}
    Similarly
    \begin{align*}
      -\mathbf{p_1s_s} -t\mathbf{s_{e_0}} &= -\mathbf{p_1(r_s +
                                            x^cs) - t(\mathbf{r_{e_0} + x^ce_0})}\\
                                          &= \mathbf{x^c}(\mathbf{-p_1s} - t\mathbf{e_0}) -\mathbf{p_1r_s}
                                            -t\mathbf{r_{e_0}} \\
                                          &= \mathbf{x^cp_0 + t_k}
    \end{align*}
    Regarding norms, we have $\norm{\mathbf{s_s}} = \norm{\mathbf{r_s +
        x^cs}} \leq
    \norm{\mathbf{r_s}} + \norm{\mathbf{s}} \leq 2\beta_0$, and
    the same for $\mathbf{\norm{s_e}, \norm{s_m}, \norm{s_{e_0}}}$.
  \item [Special Soundness.] Before proving this property, we describe the
    following technical lemma ( the detailed proof can be found in
    \cite{benhamouda2014better})
    \begin{lemma}
      Let n be a power of 2 and let $0 <i,j< 2n-1$. Then, $2(x^i -
      x^j)^{-1} \mod (x^n +1)$ only has coefficients in $\left\{ -1,
        0, 1
      \right\}$.
      \label{lem:speicalBinomial}
    \end{lemma}
    Assume that a dishonest prover does not know 'small'
    $2\mathbf{s}, 2\mathbf{e}, 2\mathbf{m}$ and $2\mathbf{e_0}$ and can
    output different accepted transcripts of a same commitment: $(c_{aux}, c',
    (d'_{aux},\mathbf{t'_c, t'_k, s'_s, s'_e, s'_m, s'_{e_0}}))$ and
    $(c_{aux}, c'', (d''_{aux}, \mathbf{t''_c, t''_k, s''_s, s''_e,
      s''_m, s''_{e_0}}))$. From the binding property of the auxilary
    commitment scheme \cite{pedersen1991non}, we have $\mathbf{t'_c = t''_c := t_c}$
    and $\mathbf{t'_k = t''_k := t_k}$. As the transcripts pass the
    checks by the verifier, it appears that:
    \begin{align*}
      &\begin{cases}
        \mathbf{x^{c'}c_0 + t_c} = -\mathbf{c_1s'_{s}} +
        t\mathbf{s'_{e}+ s'_{m}}
        \\
        \mathbf{x^{c'}p_0} + \mathbf{t_k} = -\mathbf{p_1s'_s}
        -t\mathbf{s'_{e_0}}
      \end{cases} \&
      &\begin{cases}
        \mathbf{x^{c''}c_0 + t_c} = -\mathbf{c_1s''_{s}} +
        t\mathbf{s''_{e}+ s''_{m}}
        \\
        \mathbf{x^{c''}p_0} + \mathbf{t_k} = -\mathbf{p_1s''_s}
        -t\mathbf{s''_{e_0}}
      \end{cases}
    \end{align*}
    By substracting the equations we get:
    \begin{align*}
      \begin{cases}
        \mathbf{c_0(x^{c'} - x^{c''})} = -\mathbf{c_1}(\mathbf{s'_s
          - s''_s}) + t\mathbf{(s'_e - s''_e)} +(\mathbf{s'_m -
          s''_m})\\
        \mathbf{p_0(x^{c'} - x^{c''})} = -\mathbf{p_1(s'_s - s''s)}
        - t\mathbf{(s'_{e_0} - s''_{e_0})}
      \end{cases}
    \end{align*}
    Multiplying by $2(\mathbf{x^{c'} - x^{c''}})^{-1}$:
    \begin{align*}
      \begin{cases}
        \mathbf{2c_0} = -\mathbf{c_1}2(\mathbf{s'_s
          - s''_s})(\mathbf{x^{c'} - x^{c''}})^{-1} + t2\mathbf{(s'_e -
          s''_e)}(\mathbf{x^{c'} - x^{c''}})^{-1} +2(\mathbf{s'_m -
          s''_m})(\mathbf{x^{c'} - x^{c''}})^{-1}\\
        \mathbf{p_0} = -\mathbf{p_12(s'_s - s''_s)}(\mathbf{x^{c'} - x^{c''}})^{-1}
        - t2\mathbf{(s'_{e_0} - s''_{e_0})}(\mathbf{x^{c'} - x^{c''}})^{-1}
      \end{cases}
    \end{align*}
    Let $2\hat{\mathbf{s}} = 2(\mathbf{s'_s -
      s''_s})(\mathbf{x^{c'}-x^{c''}})^{-1} $, $2\hat{\mathbf{e}} =
    2\mathbf{(s'_e - s''_e)(x^{c'} - x^{c''})^{-1}}$,
    $2\hat{\mathbf{e_0}} = 2\mathbf{(s'_{e_0}-s''_{e_0})(x^{c'} -
      x^{c''})^-1}$ and $2\hat{\mathbf{m}}=2\mathbf{(s'_m -
      s''_m)(x^{c'} - x^{c''})^{-1}}$. Applying the result from Lemma
    \ref{lem:speicalBinomial}, we see that $P$ knows the 'small' secrets
    $\norm{\hat{\mathbf{2s}}} < 2\beta_0$, $\norm{\hat{\mathbf{2e}}} <
    2\beta_0$, $\norm{\hat{\mathbf{2e_0}}} < 2\beta$ and
    $\norm{\hat{\mathbf{2m}}} < 2t$ that can pass the verifier's checks.
    This contradicts our assumption. In other words, the prover has to
    know the secret to pass the proof with probability
    $\frac{1}{2n}$.
  \item [Honest Verifier Zero-Knowledge.] The verifier can use a
    simulator $S$ to reproduce the
    protocol transcript as follows:
    \begin{itemize}
    \item $V$ samples $c \randomsample \mathcal{C}$
    \item With probability 1/M, $S$ chooses $\mathbf{s_s, s_{e_0}}
      \randomsample D_{\beta_0}$, $\mathbf{s_e} \randomsample
      D_{\beta}$ and $\mathbf{s_m} \randomsample D_t$.
    \item $S$
      computes $\mathbf{t_c} = \mathbf{-c_1s_s} + t\mathbf{s_e} +
      \mathbf{s_m} - \mathbf{x^cc_0}$ and $\mathbf{t_k} =
      -\mathbf{p_1s_s} -t\mathbf{s_{e_0}} - \mathbf{x^cp_0}$ and
      $(c_{aux}, d_{aux}) \leftarrow aCommit(\mathbf{t_c,t_k})$.
    \item $S$ outputs $(c_{aux}, c, (\mathbf{(t_c,t_k)},
      d_{aux},(\mathbf{s_s,s_{e_0},s_e,s_m})))$
    \end{itemize}
    If no abort occurs, the distribution of $\mathbf{(s_s, s_{e_0}, s_e,
      s_m)}$ does not depend on real secrets. Hence, the simulated
    transcript becomes insdistinguishable from the real one. If an abort
    occurs, the indistinguishability comes from the hiding property of
    the commitment scheme?

  \end{description}
\end{proof}

\subsection*{Summary of previous work}
\begin{description}
\item Lyubashevsky's proof systems (\cite{lyubashevsky2008lattice},
  \cite{lyubashevsky2009fiat}): This system is similar to the classical Schnorr's
  ZKP system, the main advantage is its communication size efficiency. However,
  this approach is not zero-knowledge (it is only proved to be witness
 -indistinguishable). Moreover, there is a completeness error in each round, and
  lastly, the extraction gap is $O(\sqrt{n})$.

  A quick discussion on extraction gaps: we refer to an extraction gap as a security
  parameter of ZKP systems for ISIS problem. Generally, we say that a proof accepts
  an extraction gap $\gamma$ ($\gamma > 1$) if the knowledge extractor of the
  protocol can extract a vector $\vec{v}$ such that
  $\norminf{v} = \gamma \norminf{w}$, where $\norminf{w}$ is a valid witness
  from the \emph{Prover}. Ideally, when $\gamma = 1$, one can use the extractor
  to solve the underlying ISIS instance. In other words, ZKP with $\gamma = 1$
  is strongly secure, as breaking it is at least as hard as solving the
  underlying problem. When $\gamma > 1$, the soundness of the proof has to rely
  on a stronger hardness assumption of certain potentially easier problems is hard
  to solve.
\item Micciancio-Vadhan proof system \cite{micciancio2003statistical}: This
  protocol provides ZKP for the GapCVP problem, but it can be adapted to prove the ISIS
  relation: Let $\mathbf{B}$ be a basis of the perp lattice
  $\Lambda_q^\bot(\mathbf{A}) = \{\mathbf{x} \in \mathbb{Z}^m: \mathbf{A.x = 0}\
  \mod \ q\}$.  and $\mathbf{t} \in \mathbb{Z}^m: \mathbf{A.t = y}\ \mod \ q$
  ($\mathbf{B}$ and $\mathbf{t}$ can be computed efficiently), then run the ZKP
  protocol for $GapCVP_\gamma^\infty$ with public parameters
  $(\mathbf{B,t},\beta$). The $Prover$'s witness is $\mathbf{e = t - x}$. Recall
  that The knowledge extractor of the protocol can output a vector
  $\mathbf{e'} \in \Lambda_q^\bot( \mathbf{A}$ such that
  $\norminf{\mathbf{ t - e'}} \leq g.\beta$ for some $g \geq O(\sqrt[]
  {m}$). This implies a perfect ZKPoPK with extraction gap $O(\sqrt[]{m})$.
\item Stern's protocol [\todo{citeStern}] and extension: The original Stern's
  proof worked on the SD relation \todo{SD relation}. This ZKP does not have any
  completeness error and there is no extraction gap, i.e., $\gamma =
  1$. Extensions of this work include KTX [137,85], associated with the
  following relation \todo{ktxRelation}.

  The work of \cite{ling2013improved} provides a proof for the ISIS relation
  \todo{ISIS relation}.  Stern's based techniques inherently do not have
  extraction gaps nor completeness errors, their communication efficiency is:
  \todo{missing figure}. Our protocol will also be based on this technique, the
  enhancement being that it can prove different bounds of different elements in the
  $Prover$'s witness vector. Such improvement is important in ZKPoPK for
  lattice-based cryptosystems, especially in contexts where public key settings
  and homomorphic operations are used. The bounds of messages and errors can be
  largely different: for example, the original message can be binary while the
  noises' bounds increase according to the ladder of homomorphic operations.

\end{description}


\subsection{ZKP and $\sum$-Protocol}
\label{sub:zkp_and_sum_protocol}
A Zero-Knowledge Proof of Knowledge (ZKPoK) is a two party protocol between a
Prover $P$ and a Verifier $V$. The protocol allows $P$ to convince $V$ that it
knows some secret without revealing anything about the secret. We refer readers
to \cite{bellare1992defining} for formal definition of the original ZKPoK. We
discuss a definition of the sigma protocol from \cite{benhamouda2014better} which can be adapted to suit the techniques we use in our project.

Notation: We denote a language $\mathcal{L} \subseteq \left\{ 0,1 \right\}^* $
having a witness relationship $R \subseteq \left\{ 0,1 \right\}^* \times \left\{
  0,1 \right\}^*$ if $x \in \mathcal{L} \iff \exists (x,w) \in R$, where
$w$ is a witness for $x \in \mathcal{L}$.

\begin{definition}
  \label{def:zkp-sum-protocol}
  Let (P,V) be a two-party protocol, where $V$ is PPT, and let
  $\mathcal{L},\mathcal{L'} \subseteq \left\{ 0,1 \right\}^*$ be languages with
  witness relations $\mathcal{R},\mathcal{R'}$ such that $\mathcal{R}
  \subseteq \mathcal{R'}$. $(P,V)$ is called a $\sum'-$protocol for
  $\mathcal{L}, \mathcal{L'}$ with completeness error $\alpha$, challenge set
  $\mathcal{C}$, public input $x$ and private input $w$, if and only if it
  satisfies the following conditions:
  \begin{itemize}
  \item Three-move form: The protocol is of the following form: The
    prover $P$, on input $(x,w)$, computes a commitment $t$ and sends it
    to $V$. The verifier $V$, on input $x$, then draws a challenge
    $c \randomsample \mathcal{C}$ and sends it to P. The prover sends a
    response $s$ to the verifier. Depending on the protocol transcript
    $(t,c,s)$, $V$ accepts or rejects the proof.
  \item Completeness: Whenever $(x,w) \in \mathcal{R}$, the verifier
    $V$ accepts with probability at least $1 - \alpha$.
  \item Special Soundness: There exists a PPT algorithm E, also known as
    the knowledge extractor, that takes two accepted transcript
    $(t,c',s')$,$(t,c'',s'')$ satisfying $c' \neq c''$ as inputs and
    output $w'$ such that $(x,w') \in \mathcal{R'}$.
  \item Special honest-verifier zero-knowledge (HVZK): There exists a
    simulator $S$, which is a PPT
    algorithm taking $x\in \mathcal{L}$ and $c \in \mathcal{C}$ as
    inputs and outputs $(t,s)$ so that the triple $(t,c,s)$ is
    indistinguishable from a valid protocol transcript.
  \end{itemize}
\end{definition}

This definition is different from the original sigma protocol in 2 ways.
First, it allows a completeness error $\alpha$ instead of perfect completeness
($\alpha=0$ in the original protocol).
Second, a second language $\mathcal{L}$ is introduced, with witness relation
$\mathcal{R} \subseteq \mathcal{R'}$: A prover knows a witness in $\mathcal{R}$
is guaranteed privacy, but the verifier is only ensured that the $P$ only knows
a witness for $\mathcal{R'}$. We refer to this as \emph{soundness gap}, if the
gap is small enough, it implies security guarantee for higher level application
($\mathcal{R} = \mathcal{R'}$ in the original protocol).


We present an adaption of the ZKP protocol in \cite{benhamouda2014better} to
prove the plaintext knowledge of BV cryptosystems. Recall that given
$\mathbf{(sk,pk) = (s,(p_0,p_1))}$ where $\mathbf{s} \in \chi_{\beta_0}^n$,
$\mathbf{p_0,p_1} \in R_q$ , a message $\mathbf{m} \in R_t$ is encrypted by
$\enc{\mathbf{m}} := \mathbf{(c_0, c_1)} = (\mathbf{p_0u} + t\mathbf{f + m,
  p_1u} + t\mathbf{g)}$. The protocol (Figure \ref{fig:belhamoudaProtocol}) is
an AND composition of 2 ZKPs that prove 2 relations: the secret key $\mathbf{s}$
corresponds to the public key $\mathbf{(p_0,p_1)}$, i.e.,
$\mathbf{p_0 = -p_1s} - t\mathbf{e_0}$, and the ciphertext $\mathbf{(c_0,c_1)}$
is well-formed and encrypts the message $\mathbf{m}$, that is,
$\mathbf{c_0 + c_1s} = \mathbf{m} + t\mathbf{e}$, with
$\norminf{\mathbf{e}} \leq \beta$. Note that the protocol guarantees with $V$
that $P$ knows the plaintext encrypted in $2\mathbf{c_0}$

\begin{figure}[h]
  \centering
  \begin{equation*}
    \begin{array}{c c c}
      \text{\textbf{Prover}} & & \text{\textbf{Verifier}} \\
      \\
      \mathbf{r_s,r_{e_0}} \randomsample D_{\beta_0} & & \\
      \mathbf{r_e} \randomsample D_{\beta} & & \\
      \mathbf{r_m} \randomsample D_{t} & & \\
      \mathbf{t_c} = \mathbf{-c_1r_s} + t\mathbf{r_e + r_m} & & \\
      \mathbf{t_k} = \mathbf{-p_1r_s} - t\mathbf{r_{e_0}} & & \\
      (c_{aux}, d_{aux}) = aCommit(\mathbf{t_c,t_k}) &
                                                       \xrightarrow{\hspace{1em}c_{aux}\hspace{1em}} & \\
                             & & c \randomsample \mathcal{C} = \left\{ 0,\dots, 2n -1  \right\}\\
                             &  \xleftarrow{\hspace{1em}c\hspace{1em}} & \\
      \mathbf{s_s = r_s + x^cs} & & \\
      \mathbf{s_e = r_e + x^ce} & & \\
      \mathbf{s_m = r_m + x^cm} & & \\
      \mathbf{s_{e_0} = r_{e_0} + x^ce_0} & & \\
                             & \xrightarrow{\hspace{1em}d_{aux}, \mathbf{t_c, t_k, s_s, s_e, s_m,
                               s_{e_0}}\hspace{1em}} & \\
                             & & \mathbf{x^cc_0} + \mathbf{t_c} \stackrel{?}{=} -\mathbf{c_1s_s} +t\mathbf{s_e} +
                                 \mathbf{s_m}\\
                             & & \mathbf{x^cp_0} + \mathbf{t_k} \stackrel{?}{=} -\mathbf{p_1s_s}
                                 -t\mathbf{s_{e_0}}\\
                             & & aCOpen(\mathbf{t_c, t_k}, c_{aux}, d_{aux}) \stackrel{?}{=} accept \\
                             & & \norm{s_s}, \norm{s_{e_0}} \leq 2\beta_0 \\
                             & & \norm{s_e} \leq 2\beta \\
                             & & \norm{s_m} \leq 2t
    \end{array}
  \end{equation*}
  \caption{ZKP for BV cryptosystem relation}
  \label{fig:belhamoudaProtocol}
\end{figure}



\subsection{Combination of ZKP}
\label{sec:combination-zkp}
A $\sum-$protocol can be composed together to construct more complex relations.
There are several forms of decomposition such as AND, OR, NEQ, etc.  We describe
some forms of composition of the \(\sum-protocol\) that are used in our own protocol:
AND-composition, OR-composition. We first describe the generic \(\sum-\)protocol
and its combinations. The BV-ZKP (Figure \ref{fig:belhamoudaProtocol}) protocol
is an instance of such a protocol and the technique can be applied inherently.
\begin{description}
\item[$\sum-$protocol] The protocol is a generic 3-moves transaction between 2 parties
  \(Prover\) and \(Verifier\), it is used to prove (supporting zero-knowledge) a
  relation \(R(x,w)\), where \(x\) is the public parameter known by both
  parties and \(w\) is a witness known by the \(Prover\) only. The protocol's
  view is a set of 3 messages (Figure \ref{fig:sigmaProtocol}): the commitment
  \(c\) is a function of a random factor \(\rho\), the challenge \(ch\) is
  normally random, and the response \(r\) is a function computed from
  \(x, w, \rho, ch\). There are 2 extra algorithms for the \(\sum-\)protocol: a
  \(verify(r,ch,c)\) algorithm used by the \(Verifier\) in the last step to
  check the correctness of the proof result, and a simulator \(sim\), taking
  \(x\) and a random parameter \(\rho'\) as inputs, and and outputting a view
  \(\bar{c},\bar{ch},\bar{r}\) that is indistinguishable from the genuine view
  of the protocol.
  \begin{figure}[h!]
    \centering
    \begin{equation*}
      \begin{array}{c c c}
        \text{\textbf{Prover}} & & \text{\textbf{Verifier}} \\
        \\
        \rho \randomsample random & & \\
        c = comm(\rho) & & \\
                               & \xrightarrow{c} & \\
                               & & ch \randomsample random \\
                               & \xleftarrow{ch} & \\
        r = resp(\rho,w,x,ch) & & \\
                               & \xrightarrow{r} & \\
                               & & verify(r, ch, c)\\
      \end{array}
    \end{equation*}
    \caption{Sigma Protocol}
    \label{fig:sigmaProtocol}
  \end{figure}
  
\end{description}


\begin{description}
\item[AND-COMPOSITION] Given two relations $R_1 = \left\{ (v_1,w_1) \right\}$
  and $R_2 = \left\{ (v_2, w_2) \right\}$ with the same challenge space, a
  $\sum$-Protocol of
  $R_1 \wedge R_2 = \left\{ (v_1, v_2, w_1, w_2): (v_1;w_1) \in R_1, (v_2,w_2)
    \in R_2\right\}$ can be obtained by running a $\sum$-Protocol for $R_1$ and
  a $\sum$-Protocol for $R_2$ in parallel, using a \emph{common} challenge.
  Figure \ref{fig:belhamoudaProtocolAND} is a concrete example combining 2 ZKP for BV.
  
  \begin{figure}[h!]
    \centering
    \begin{equation*}
      \begin{array}{c c c}
        \text{\textbf{Prover}} & & \text{\textbf{Verifier}} \\
        \\
        \mathbf{r_s,r_{e_0},r'_{s},r'_{e_{0}}} \randomsample D_{\beta_0} & & \\
        \mathbf{r_e,r'_{e}} \randomsample D_{\beta} & & \\
        \mathbf{r_m,r'_{m}} \randomsample D_{t} & & \\
        \mathbf{t_c} = \mathbf{-c_1r_s} + t\mathbf{r_e + r_m} & & \\
        \mathbf{t_k} = \mathbf{-p_1r_s} - t\mathbf{r_{e_0}} & & \\
        \mathbf{t'_c} = \mathbf{-c_1r'_s} + t\mathbf{r'_e + r'_m} & & \\
        \mathbf{t'_k} = \mathbf{-p_1r'_s} - t\mathbf{r'_{e_0}} & & \\
        (c_{aux}, d_{aux}) = aCommit(\mathbf{t_c,t_k}) & & \\
        (c'_{aux}, d'_{aux}) = aCommit(\mathbf{t'_c,t'_k}) &
                                                         \xrightarrow{\hspace{1em}c_{aux},c'_{aux}\hspace{1em}} & \\
                               & & c \randomsample \mathcal{C} = \left\{ 0,\dots, 2n -1  \right\}\\
                               &  \xleftarrow{\hspace{1em}c\hspace{1em}} & \\
        \mathbf{s_s = r_s + x^cs},\mathbf{s'_s = r'_s + x^cs} & & \\
        \mathbf{s_e = r_e + x^ce},\mathbf{s'_e = r'_e + x^ce} & & \\
        \mathbf{s_m = r_m + x^cm},\mathbf{s'_m = r'_m + x^cm} & & \\
        \mathbf{s_{e_0} = r_{e_0} + x^ce_0},\mathbf{s'_{e_0} = r'_{e_0} + x^ce_0} & & \\
                               & \xrightarrow[\hspace{1em}d'_{aux}, \mathbf{t'_c, t'_k, s'_s, s'_e, s'_m,
                                 s'_{e_0}}\hspace{1em}]{\hspace{1em}d_{aux}, \mathbf{t_c, t_k, s_s, s_e, s_m,
                                 s_{e_0}}\hspace{1em}} & \\
                               & & \mathbf{x^cc_0} + \mathbf{t_c} \stackrel{?}{=} -\mathbf{c_1s_s} + t\mathbf{s_e} + \mathbf{s_m}\\
                               & & \mathbf{x^cc_0} + \mathbf{t'_c} \stackrel{?}{=} -\mathbf{c_1s'_s} + t\mathbf{s'_e} + \mathbf{s'_m}\\
                               & & \mathbf{x^cp_0} + \mathbf{t_k} \stackrel{?}{=} -\mathbf{p_1s_s} - t\mathbf{s_{e_0}}\\
                               & & \mathbf{x^cp_0} + \mathbf{t'_k} \stackrel{?}{=} -\mathbf{p_1s'_s} - t\mathbf{s'_{e_0}}\\
                               & & aCOpen(\mathbf{t_c, t_k}, c_{aux}, d_{aux}) \stackrel{?}{=} accept \\
                               & & aCOpen(\mathbf{t'_c, t'_k}, c'_{aux}, d'_{aux}) \stackrel{?}{=} accept \\
                               & & \norm{s_s}, \norm{s_{e_0}},\norm{s'_s}, \norm{s'_{e_0}} \leq 2\beta_0 \\
                               & & \norm{s_e},\norm{s'_e}  \leq 2\beta \\
                               & & \norm{s_m},\norm{s'_m} \leq 2t
      \end{array}
    \end{equation*}
    \caption{AND-Composition for ZKP-BV }
    \label{fig:belhamoudaProtocolAND}
  \end{figure}

\item[OR-Compostion] In this composition, given the $\sum-protocol$ for many  
  relations $R_{1}$,$R_{2}$,\dots,\(R_{n}\) the goal is to construct a protocol for the
  relation
  $R_{OR}(\vec{x}, w_{i}) $, where \(\exists i \leq n: R(x_{i},w_{i}) = 1\). The main reason behind this composition is that the verifier
  can let the prover use the simulator of the \(\sum-protocol\) for the
  relations \(R_{j}\), for which the prover does not know the witness.
  The verifier provides a single challenge \(c\)
  such that the prover can split that into challenges \(c_{1}, c_{2}, \dots, c_{n}\)
  provided that \(c_{i}\) satisfies a linear constraint in terms of \(c\),
  for example \(c = c_{1} \xor c_{2} \xor \dots \xor c_{n}\). The final OR-combination proof is
  obtained by composing one run of the \(\sum-protocol\) with other runs of the
  simulators for the \(\sum-protocol\). (Figure \ref{fig:OR-Combination})
  \begin{figure}[h!]
    \centering
    \begin{equation*}
      \begin{array}{c c c}
        \text{\textbf{Prover}} & & \text{\textbf{Verifier}} \\
        \\
        \rho_{i} \randomsample random & & \\
        c_{i} = comm(\rho_{i}) & & \\
        \text{For } j = 1,\dots,n \wedge j \neq i: & & \\
        \text{    } \rho_{j} \randomsample random; & & \\
        \text{    } (c_{j}, ch_{j}, r_{j}) \gets ZKPSim(\rho_{j}, x_{j}) & & \\
                               & \xrightarrow[ch_{j}]{c_{1}, c_{2}, \dots, c_{n}} & \\
                               & & ch \randomsample \mathbb{Z}_{n} \\
                               & \xleftarrow{ch} & \\
        ch_{i} = ch - \sum_{j \neq i}{ch_{j}} & & \\
        r_{i} = resp(\rho_{i}, w_{i}, x_{i}, ch_{i}) & & \\
                               & \xrightarrow{r_{1}, r_{2}, \dots, r_{n}} & \\
                               & & \forall i \in [n], ver(r_{i}, ch_{i}, c_{i}) = 1 \\
                               & & ch = \sum_{i \in [n]}ch_{i}\\
      \end{array}
    \end{equation*}
    \caption{}
    \label{fig:OR-Combination}
  \end{figure}
\end{description}



\section{Proposed Scheme}
We propose a secure fingerprint authentication scheme that combines a Somewhat
Homomorphic Encryption (SHE) with a Zero-Knowledge Proof (ZKP) to provide privacy
features with low FAR overhead. The scheme is secure under a hybrid model that
assumes an active client and an
honest but curious (HBC) server. The server $\server$ is considered to be HBC
by assuming that it can be audited regularly. This scheme uses Hamming
Distance (HD) as the main measure unit to determine the difference between two
fingerprint templates.

\subsection{The protocol}
\label{sec:theProtocol}
\begin{description}
	\item[Setup] The server and the user run the setup process as
	follows:
	\begin{itemize}



		% * <trung.dinh@monash.edu> 2016-10-21T13:17:43.354Z:
		%
		% replace BGV by GSW for now
		%
		% ^.

		\item $\mathcal{S}$ invokes $params_{BV} \gets
		SGen_{BV}(1^\lambda)$
		\item We are currently using a BV cryptosystem
		(\cite{brakerski2011fully}). We refer the reader to section
		\ref{sec:BVScheme} for details of $params_{BV}$, the public
		key $pk$, the private key $sk$, as well as the
		operations of the
		cryptosystem.
		\item A user $\mathcal{U}_k$ invokes $(pk_k,sk_k) \gets
		UGen_{BGV}(params_{BGV})$ and makes $pk_k$ publicly
		available to $\mathcal{S}$.




		\iffalse
		\item $\mathcal{S}$ invokes $params_{GSW} \gets
		SGen_{GSW}(1^\lambda)$
		\item We are currently using GSW cryptosystem
		(\cite{gentry2013homomorphic}).
		We refer the reader to section
		\missref{} for details of $params_{GSW}$, the public
		key $pk$, the private key $sk$, as well as the
		homomorphic operations of the
		cryptosystem.
		\item A user $\mathcal{U}_k$ invokes $(pk_k,sk_k) \gets
		UGen_{GSW}(params_{GSW})$ and make $pp_k$ publicly
		available to $\mathcal{S}$
		\fi


	\end{itemize}
	\item[Enrolment] The enrolment process runs as follows.
	\begin{itemize}
		\item $\mathcal{U}$ uses a specific sensor and algorithm to
		extract his biometric template $X$. $\mathcal{U}$
		encrypts $X$ with his public key $pk_k$ to get
		$T_k = Enc^{(1)}(X)$.
		\item $\mathcal{U}$ sends $(k,T_k)$ to $\mathcal{S}$.
		Noted that $k$
		is used as an identity index for $\mathcal{U}$.
		\item $\mathcal{S}$ stores a tuple $(k, T_k)$ as a
		record.
	\end{itemize}
	\item[Authentication] The authentication process for a user
	$\mathcal{U}_k$ is as follows.
	\begin{enumerate}
		\item $\user_k$ extracts his query template $Y$. He
		encrypts $Y$ with his public key $pk_k$ to obtain
		$Q_k = Enc^{(1)}(Y)$.\label{protocol:step1}
		\item $\user_k$ sends $(k,Q_k)$ to $\server$ and
		runs $\mathbf{ZKPValidEnc((Q_k,pk_k),(Y,sk_k))}$ to prove the
		validity of $Y$.\label{protocol:step2}
		\item $\server$ locates the record $(k,T_k)$ and computes
		\                        the encrypted Hamming Distance $C_{HD} = Enc^{(1)}(
		HD)$ of $X$ and
		$Y$, using the homomorphic operation discussed in
		Appendix \ref{sec:HDComp}
		$$C_{HD} \gets
		\textbf{EvalDistance}(T_k,Q_k).$$\label{protocol:step3}
		\item $\server$ masks the $C_{HD}$ by sampling $r
		\randomsample \mathcal{P}$
		and performs one homomorphic addition to get
		$C_{HD'} = Enc^{(1)}(HD + r) \gets Enc^{(1)}(HD) + Enc^{(1)}(r)$.
		The result ciphertext is sent to $\user_k$.\label{protocol:step4}
		\item $\user_k$ uses his private key $sk_k$ to decrypt $C_{HD'}$
		and sends
		the re-encryption $C_{HD'_0} = Enc^{(1)}(HD',0,0,\dots,0)$ back to $\server$.
		$\user_k$ also decomposes the plaintext result
		$HD' = HD+r$ into its binary representation:
		\[
		HD' = b_0 + b_12^1 + \dots + b_l2^{l-1}
		\]
		and sends $C_i = Enc^{(1)}(b_i)$ to $\server$
		for $i = 0, \dots, l-1$.\label{protocol:step5}

		\item $\user_k$ and $\server$ run the $\mathbf{ZKPUnpack}(C_{HD},C_{HD_0'})$ and
		$\mathbf{ZKPBinDecomp}(C_{HD_0'},C_i)$
		protocols to convince the server that
		$\user_k$ did follow the protocol transcript correctly. This is detailed
		in section
		\ref{sec:ZKPReencrypt}.
		\label{protocol:step6}
		\item $\server$ computes $C_{HD}'' = Enc^{(2)}(2^l + t - HD) \gets
		Enc^{(2)}(2^l + t) - Enc^{(2)}(HD+r) + Enc^{(2)}(r)$, where
		$Enc^{(2)}(HD + r)$ is computed by $\mathbf{ToUnary}(C_i)$. We note that
		$Enc^{(2)}$ is the second mode of encryption with the message
		encoded in the exponent of the polynomial, which allows the
		Most significat bit (MSB)
		extraction on the ciphertext (this is detailed section \ref{sec:binToUna} \label{protocol:step7}).
		\item $\server$ does $Enc^{(3)}(res) \gets
		\mathbf{MSBExtract}(C_{HD}'')$, this is the ciphertext
		of the authentication result, which is sent to $\user_k$. This
		is described in section \ref{sec:MSBExtract}.
		\label{protocol:step8}
		\item $\user_k$ decrypts the result $res$ and sends it to $\server$
		(it will be either \textbf{Accepted} or \textbf{Rejected} by $\server$).
		$\user_k$ also runs another proof $\mathbf{ZKPCorrectDec}(res)$
		to convince $\server$ that he
		did follow the protocol honestly (Section \ref{sec:ZKPReencrypt}).\label{protocol:step9}




		%$\server$ also computes
		%the encryption of the authentication result $Enc(\Delta < \tau)$
		%using another homomorphic operation $Enc(\Delta \stackrel{?}{<}
		%\tau) \gets \textbf{EvalRes}(pk_k, \tau, Enc(\Delta))$.
		%\item $\server$ sends $Enc(\Delta \stackrel{?}{<} \tau)$ to $\user_k$.
		%$\user_k$ uses his private key $sk_k$ to decrypt the plaintext $
		%res \gets \Delta
		%\stackrel{?}{<} \tau$.



		% * <trung.dinh@monash.edu> 2016-10-21T13:15:14.957Z:
		%
		% we agreed to do this later, for now, we change back to GSW instead of BGV. Later when we apply MCC we will consider bringing these garble circuit back.
		%
		% ^.
		%\item $\server$ masks the computed distance with a random
		%value $R$, using Homomorphic addition operation:
		%$Enc(\Delta + R) \gets EvalAdd(pk_k, Enc(\Delta),
		%Enc(R))$.
		%\item $\server$ builds a garbled circuit $\textbf{GC}$ to evaluate
		%the bit value of the comparison between a plaintext $\Delta$
		%against a threshold
		%$\tau$ privately $(\Delta \stackrel{?}{<} \tau) \gets
		%\textbf{GC}(k_{\Delta + R}, k_R)$. We note that
		%$k_{\Delta + R}$ and $k_R$ are cryptographic keys input
		%to garble circuit protocol. We refer the reader to
		%section \missref{} for details of garble circuit
		%protocols.
		%\item $\server$ sends $Enc(\Delta + R)$ and $\textbf{GC}$ to $\user_k$, $\user_k$
		%uses his private key $sk_k$ to decrypt $\Delta+R$.
		%\item $\user_k$ derives $k_{\Delta + R}$ to be use as the
		%first input to $\textbf{GC}$ and $\user_k$ runs Oblivious Transfer protocol
		%$\textbf{OT}$ to obtain $k_R$ from $\server$ privately.
		%$\textbf{OT}$ is discussed in section
		%\missref{}.
		%\item $\user_k$ evaluates $(\Delta \stackrel{?}{<} \tau) \gets
		%\textbf{GC}(k_{\Delta + R}, k_R)$ and sends the result
		%$res$ to $\server$.





		%\item $\user_k$ convinces $\server$ that he did follow the
		%protocol honestly using Zero Knowledge Proof protocol
		%$\textbf{ZKP}$. This protocol is discussed in section
		%\missref{}.

	\end{enumerate}
	The proposed scheme satisfies the security notions defined in Sect. \ref{sec:syntaxModel}, proofs are provided in Appendix
    \ref{append:Proofs}
	\begin{theorem}
		\label{theo:server}
		Under the IND-CPA security of a BV cryptosystem, and the zero-knowledge
		property of the Stern protocol, the proposed scheme satisfies an (Honest But Curious) Server Privacy's Security.
	\end{theorem}
	\begin{theorem}
		\label{theo:client}
		Under the IND-CPA security of a BV cryptosystem and the soundness
		property of the underlying Stern protocol, the proposed scheme satisfies Impersonation Security. Concretely, for $\delta>0$, the protocol is $(q,c)$-secure against impersonation with $c \leq c(\delta) + 3 \cdot c_1$, assuming the underlying non-private biometric protocol has imperonsation probability $\varepsilon_{bio}$ and the underlying Stern ZK protocols have knowledge errors $\eps_{ZK1},\ldots,\eps_{ZK4}$ such that $q(\varepsilon_{ZK1}+\varepsilon_{ZK2} +
\varepsilon_{ZK3} + \varepsilon_{ZK4}) + \delta \leq c_1 \cdot \varepsilon_{bio}$, $c(\delta) = 2 e^{1+2\delta}$, and the condition $\sigma/r_0 \geq 4 \pi k n q$ holds, with $k = 1 + \sqrt{1/\pi \ln(2nq/\delta)}$ and $r_0$ being an upper bound on the size of the noise in $C_{HD}$.
	\end{theorem}

\end{description}

\section{Security Proofs}
\label{append:Proofs}
\subsection{Security Proof for Theorem~\ref{theo:client}: Type I Impersionation attack}
The proof of theorem \ref{theo:server} and  \ref{theo:client} can be provided using a sequence of games between the challenger $\challenger$ and the adversary $\attacker$. We present
a sequence of games as well as the relations among them to demonstrate the type I security model proof.\\\\
\textit{Game 0}. Game 0 is the original impersonation game for type I attack.
\begin{description}
	\item [Setup.] $\challenger$ intiates $D_k \randomsample D_{bio}$ and $X_k
	\randomsample D_k$. $\challenger$ sets up $(sk_k, pk_k)$ and executes
	$Enrol(k, X_k)$ to get $(sk_k, T_k =(pk_k, C_k = Enc^{(1)}_{pk_k}(X_k)))$.
	$\attacker$ submits the attack query type I and receives $sk_k$ from
	$\challenger$.
	\item [Query.] $\attacker$ runs $q$ authentication sessions. In each session $j
	= 1, \dots, q$,
	$\attacker$ sends $(Q_k^{(j)} = Enc^{(1)}(Y^{(j)}))$. $\attacker$ and
	$\challenger$ runs $\mathbf{ZKPValidEnc}(Q_k^{(j)},Y^{(j)})$. $\challenger$ evaluates
	$C_{HD} = \mathbf{EvalDistance}_{pk_k}(C_k, Q_k^{(j)})$, then computes
	$C_{HD'} = (-1)C_{HD} + Enc_{pk_k}^{(1)}(r_{HD'},e_{HD'})$ for $r_{HD'}
	\randomsample \mathcal{P}$ and $e_{HD'} \randomsample \chi_{HD}$. The
	result ciphertext is sent to $\attacker$, $\attacker$ decrypts $C_{HD'}$
	and decomposes it into bits and further sends back the ciphertexts $C_0^{(j)}, \dots,
	C_{l-1}^{(j)} (= Enc^{(1)}(b_i), i = 0,\dots, l-1)$, as well as the
	re-encryption $C_{HD_0'}$. $\attacker$ and $\challenger$ engage
	$\mathbf{ZKPUnpack}(C_{HD},C_{HD_0'})$ and $\mathbf{ZKPBinDecomp}(C_{HD_0'},
	C_i^{(j)})$.
	$\challenger$ evaluates $C_{HD}'' = Enc^{(2)}(2^l + t) +
	\mathbf{ToUnary}(C_i^{(j)}) + Enc^{(2)}(-r) $ to get $Enc^{(2)}(2^l + t -
	HD)$. $\challenger$ computes $Enc^{(3)}(res) \gets
	\mathbf{MSBExtract}(C_{HD}'')$ and sends the result to $\attacker$. $\attacker$
	decrypts it and sends the authentication result bit back. $\challenger$ and
	$\attacker$ then fire $\mathbf{ZKPCorrectDec}(res)$ to trigger the server's acceptance of the
	authentication result. At the end, the server outputs \textbf{Accept} if
	all the proofs pass and $res = \mathbf{Accept}$.
\end{description}
Next, we discuss the games that follow, the plan being to proceed towards the final game where 
everything $\attacker$ receives relating to $X_k$ can be simulated
without any knowledge about $X_k$, except that $X_k$ is
the function $Verify(X_k, Y)$. Let $res_s = Verify(X_k, Y^{(j)})$ and $S_i$ be
the event in the game $i$ such that $res_s = Accept$.\\
\textit{Game 1}. In this game, we abort $\mathbf{ZKPValidEnc}$ if $Q_k^{(j)}$
is not a valid encryption of the query, but the $Prover$ manages to pass the
proof. Let $(*)_1$ be this event.
\[
(*_1)res_s = \begin{cases}
\text{Reject if } \mathbf{ZKPValidEnc} \text{ fails}\\
\text{res else}
\end{cases}
\]
Let $bad_0$ be the event in game 0 : $\exists j \leq q\  s.t\  (*_1)\
\textnormal{is thus the case}$. We want to show that when we modify \textit{game 0}, the
probability of a successful forgery $S_1$ in this \textit{game 1} is not much
lower than what it was. Due to the modification, we observe that
$
Pr[S_1] \geq Pr[S_0] - Pr[bad_0]
$
.For any $j$ in the $q$ authentication attemps, by the $\varepsilon-soundness$ property of
$\mathbf{ZKPValidEnc}$ as a proof of membership in (*), we have $Pr[(*_1)\
occurring\ for\ some \ j] \leq \varepsilon_{ZK1}$. So, the probability of $bad_0$
would be the union of these events, which is bounded by $Pr[bad_0] \leq
q\varepsilon_{ZK1}$. In other words, the advantage of $\attacker$ in \textit{game
	1} is
\[
Pr[S_1] \geq Pr[S_0] - Pr[bad_0] \geq \varepsilon_{imp} - q\varepsilon_{ZK1}
\]
\\
\textit{Game 2}. In this game, we abort $\mathbf{ZKPUnpack}$ if, in one of the
$j^{th}$ runs, the $Verifier$ accepts but the ciphertext does not satisfy the
relation. Let $bad_1$ be this event, by the same type of argument, we can
derive $Pr[bad_1] \leq q\varepsilon_{ZK2}$ and therefore
$$Pr[S_2] \geq Pr[S_1]
- Pr[bad_1] \geq \varepsilon_{imp} - q(\varepsilon_{ZK1}+\varepsilon_{ZK2})
$$
\textit{Game 3 and Game 4}. Similarly, we abort $\mathbf{ZKPBinDecomp}$ and
$\mathbf{ZKPCorrectDec}$ if, in any $j^{th}$ runs, the $Verifier$ accepts even
when the correctness of the ZKP is not satisfied. We have
$$Pr[S_3] \geq  \varepsilon_{imp} - q(\varepsilon_{ZK1}+\varepsilon_{ZK2}
+\varepsilon_{ZK3})
$$ and
$$Pr[S_4] \geq  \varepsilon_{imp} - q(\varepsilon_{ZK1}+\varepsilon_{ZK2} +
\varepsilon_{ZK3} + \varepsilon_{ZK4})
$$
By the end of \textit{Game 4}, if in any authentication attempt $j$, there is
no abort while running any of the 4 games, then, by the correctness property of ZKP, the
server output is equal to the output of $Verify(X_k, Y^{(j)})$. In other words,
we have shown what we could get by just querying the oracle $Verify()$. Next,
we want to simulate everything related to $X_k$ the attacker can see using
just that oracle.\\
\textit{Game 5.} At the end of \textit{Game 4}, $\challenger$ possesses the bit
$b = Verify(Y^{(i)},X_k)$. In this game, we can change $C_{res}^{(j)}$ from
$\mathbf{MSBExtract}(C_{HD}'') = Enc(b;e_{res})$ to
$Enc(verify(Y^{(i)},X_k);e_{res})$, given that the challenger can use the
secret key to extract $e_{res}$. Despite this change,  
the same ciphertext is still accessible to $\attacker$, so its probability of winning of 
is the same as in \textit{Game 4}.\\
\textit{Game 6.} In this game, we change the way $\challenger$ computes
$C_{HD}''$: In the orignal game 0, $Enc(-r)$ was added to remove the mask. We now
want to remove this $r$ from being used anywhere in the game, so we replace
this with $Enc(0)$. This change does not affect $\attacker$'s success
probability: $r$ only affects the plaintext inside $C_{HD}''$, since we do not
use this plaintext anymore (as it has been replaced in \textit{Game 5}), so this change
does not affect the information available to the attacker. Again, $Pr[S_6] = Pr[S_5] = Pr[S_4]$.\\
\textit{Game 7.} We modify the way $C_{HD}'$ is computed in this game. Instead
of calculating $C_{HD}' \gets (-1)C_{HD} + Enc(r;e_{HD'})$, the challenger chooses a
random $HD' \randomsample \mathbb{Z}_p$ and encrypts it with the noise used
before: $C_{HD}' \gets Enc(HD'; -e_{HD} + e_{HD'})$. In this game, the
plaintext has changed from being $r + HD$ to a uniform $HD' \in \mathbb{Z}_p$.
Since $r$ is also uniform in $\mathbb{Z}_p$, the attacker is confronted with a uniform
plaintext in both cases. Therefore, $Pr[S_7] = Pr[S_6]$.\\
\textit{Game 8.} Finally, we set $C_{HD'} = Enc(HD', e_{HD'})$ for $e_{HD'}
\randomsample \chi_{mask}$ instead of $-e_{HD} + e_{HD'}$. We replace the sum
of the Gaussian noise with a random noise. In Section \ref{sec:Renyi}, we
showed that $Pr[S_8] \geq \frac{1}{c(\delta)}(Pr[S_7]-q \cdot \delta)$, where $c(\delta) = RD(-e_{HD} + e_{HD'},
e_{HD}) \leq 2 \cdot e^{1+2\delta}$ by Lemma~\ref{le:Renyi} and by our assumption on the parameter's values. After we finish \textit{Game 8}, we notice that all the messages available to the attacker can be simulated with only the verified bit $b =
Verify(Y^{(i)}, X_k)$. We now have an attacker $A'$ against the biometric
impersonation with advantage:
\[
\varepsilon_{bio} = Adv(A') = Pr[S_8] \geq \frac{1}{c(\delta)}(\varepsilon_{imp} - q(\varepsilon_{ZK1}+\varepsilon_{ZK2} +
\varepsilon_{ZK3} + \varepsilon_{ZK4}) + \delta),
\]
which gives the claimed bound $\varepsilon_{imp} \leq c(\delta) \cdot \varepsilon_{bio} + q \cdot (\varepsilon_{ZK1}+\varepsilon_{ZK2} +
\varepsilon_{ZK3} + \varepsilon_{ZK4}) + \delta \leq (c(\delta)+c_1) \cdot \varepsilon_{bio}$ if $q(\varepsilon_{ZK1}+\varepsilon_{ZK2} +
\varepsilon_{ZK3} + \varepsilon_{ZK4}) + \delta \leq c_1 \cdot \varepsilon_{bio}$.


\subsection{Security Proof for Theorem~\ref{theo:client}: Type II Impersionation attack}
\label{append:ProofsTypeII}
The proof of Theorem \ref{theo:client} can be provided using a sequence of games between the challenger $\challenger$ and the adversary $\attacker$. We present
a sequence of games as well as the relations among them to demonstrate the type II security model proof. The idea is that in this type of attack, $sk_k$ is not used to compute the view of $\attacker$. On the other hand, the soundess of the zero-knowledge proof of knowledge $\mathbf{ZKPValidEnc}$ implies the existence of an efficient witness extractor algorithm, that can be used to extract the witness (i.e. the secret key $sk_k$) from a cheating prover succeeding with probability non-negligibly higher than the knowledge error of the zero-knowledge proof, thus contradicting the IND-CPA security of the BV encryption scheme. \\\\
\textit{Game 0}. Game 0 is the original impersonation game for a type II attack, i.e., the same as Game 0 in the proof of security against Type I attacks, except that $(T_k =(pk_k, C_k = Enc^{(1)}_{pk_k}(X_k)))$ is given by $\challenger$ to $\attacker$ at the beginning of the game, rather than $sk_k$.
For $j \in \{1,\ldots,q\}$, let $res^{j}$ denote the result of the $j$th authentication protocol run between $\attacker$ and $\challenger$, and $S_0$ be
the event in the game $0$ such that $res^{j} = Accept$ for some $j=1,\ldots,q$. We have $\Pr[S_0] = \varepsilon_{imp,II}$ as the type II success probability of $\attacker$. \\\\
\textit{Game 1}. From the definition of event $S_0$ in Game 0, it follows that there exists some $j^* \in \{1,\ldots,q\}$ such that $\Pr[res^{j^*} = Accept] \geq \varepsilon_{imp,II}/q$. Furthermore, by an averaging argument, there must exist a set $G$ of $(D_k,X_k,pk_k)$ such that $\Pr[(D_k,X_k,pk_k) \in G] \geq \varepsilon_{imp,II}/(2 \cdot q)$, and for each $(D'_k,X'_k,pk'_k) \in G$, we have $\Pr[res^{j^*} = Accept |(D_k,X_k,pk_k)=(D'_k,X'_k,pk'_k)] \geq  \varepsilon_{imp,II}/(2 \cdot q)$. By $\varepsilon_{ZK1}$-soundness of the zero-knowledge proof of knowledge $\mathbf{ZKPValidEnc}$ (cite Golderich's `Foundations of Cryptography' book, volume 1, Prop. 4.7.5), there exists a witness extractor algorithm that runs in expected time $T'=O(\mathrm{poly}(n \log Q) \cdot T / (\varepsilon_{imp,II}/(2*q) - \varepsilon_{ZK1}))$, where $T$ denotes the run-time of $\attacker$ and outputs a witness containing $sk_k$ for ${ZKPValidEnc}$. Therefore, we obtain a (secret key recovery) attack algorithm against the IND-CPA security of the BV encryption scheme, with expected run-time $T'$ and advantage $\varepsilon' \geq \varepsilon_{imp,II}/(2 \cdot q)$. Hence,  if $\varepsilon_{imp,II}/(2*q) - \varepsilon_{ZK1} > \varepsilon_{imp,II}/(4*q)$, or equivalently, if $\varepsilon_{imp,II} > 2 \cdot q \varepsilon_{ZK1}$, we obtain a contradiction with the assumption the BV encryption scheme with parameters $Q,n,\sigma$ is IND-CPA against attacks with expected time $O(\mathrm{poly}(n \log Q) \cdot T / \varepsilon_{ZK1})$ and advantage $\geq \varepsilon_{ZK1}$. It follows under the latter assumption that $\varepsilon_{imp,II} \leq 2q \varepsilon_{ZK1} \leq 2 c_1  \cdot \varepsilon_{bio}$, under the assumption that  $q(\varepsilon_{ZK1}+\varepsilon_{ZK2} +
\varepsilon_{ZK3} + \varepsilon_{ZK4} + \delta) \leq c_1 \cdot \varepsilon_{subsection}$.


\subsection{Security Proof for Theorem~\ref{theo:server}: Privacy against Server}
\label{append:ProofsPrivacy}
The proof of Theorem \ref{theo:client} can be done using a sequence of games between the challenger $\challenger$ and the adversary $\attacker$. We present a sequence of games. The idea is to proceed to remove $sk_k$ and $X_k$ from being used to compute the view of $\attacker$, except for $Verify(X_k,Y_k^{j})$ queries, as in the ideal game, relying on the correctness of the protocol and the IND-CPA security of the BV encryption scheme. \\\\
\textit{Game 0}. Game 0 is the original real privacy game, in which $(T_k =(pk_k, C_k = Enc^{(1)}_{pk_k}(X_k)))$ is given by $\challenger$ to $\attacker$ at the beginning of the game. Then, for $j=1\ldots,q$, the attacker sends $Y_k^{(j)} \in \{0,1\}^n$ to $\challenger$, and the latter simulates a run of the authentication protocol between an honest client with input $(k,Y_k^{(j)}, sk_k)$ and an honest server with input $(k,T_k)$, returning to $\attacker$ the protocol view $V^{(j)}_S$ of the server. Finally, $\attacker$ outputs a bit $\beta$. In the following Game $i$, we let $S_i$ denote the event of $\beta=1$.\\\\
\textit{Game 1}. We change the computation of the authentication result bit $res^{(j)}$ sent by client to server from the decryption of the ciphertext $\textbf{MSBExtract}(C''_{HD}$ (its value in Game 0) to the result returned by $Verify(X_k, Y^{(j)})$. By correctness of the protocol, this does not change the value of $res^{(j)}$, so $\Pr[S_1] = \Pr[S_0]$. \\\\
\textit{Game 2}. We change the computation of the zero-knowledge protocol transcripts. Instead of computing those transcripts using the secret witnesses, we simulate them using the statistical zero-knowledge simulator algorithms for the zero-knowledge proofs. By the zero-knowledge property, this is a perfect simulation, yielding $\Pr[S_2]= \Pr[S_1]$.\\\\
\textit{Game 3}. We change the computation of the ciphertexts $C^{(j)}_i$ for $i=0,\ldots,l-1$ and $Q^{(j)}_k$ for $j=1,\ldots,q$ and $C_k$ to encrypt zero messages, instead of encrypting the secret-related messages as in the previous game. Since now $sk_k$ is not used anywhere in generating the view of $\attacker$, it follows by a hybrid argument that $|\Pr[S_3]-\Pr[S_2]| ((l+1) \cdot q + 1) \cdot \varepsilon_{BV}$, where $\varepsilon_{BV}$ denotes the maximal advantage of an attacker against IND-CPA of BV scheme against attacks with run-time $T + \mathrm{poly}(n, \log Q)$, where $T$ is the run-time of $\attacker$.
In this game, since the only information on $X_k$ comes via the $Verify(X_k,Y_k^{j})$ queries, the challenger together with $\attacker$ constitute an efficient attacker against the ideal privacy game, which outputs 1 with probability different by at most $(l+1) \cdot q + 1) \cdot \varepsilon_{BV}$ relatively to the probability of outputting 1 in the real privacy game, as required.



\section{The algorithms}
	\begin{algorithm}
		\caption{HD Computation Homomorphically}\label{alg:EvalDistance}
		\begin{algorithmic}[1]
			\Procedure{EvalDistance}{$\mathbf{T,Q}$}
			\State $C_1 \gets - \sum_{i=0}^{n-1}x^{n-i}$
			\State $C_2 \gets 2 - C_1$
			\State $C_{HD} \gets ct_1(\mathbf{T})*Enc(C_1) + ct_2(\mathbf{Q})*
			Enc(C_2) - 2*ct_1(\mathbf{T})*ct_2(\mathbf{Q})$
			\State \textbf{return} $C_{HD}$
			\EndProcedure
		\end{algorithmic}
	\end{algorithm}

    \begin{algorithm}
	\caption{ZKP of encoding transform}\label{alg:ZKPBinDecomp}
	\begin{algorithmic}[1]
		\Procedure{ZKPBinDecomp}{$\mathbf{c, c_i}$}
		\State Let $\mathbf{c'} \gets \sum_{i=0}^{l-1}\mathbf{c_i}2^i$
		\State Let $\mathbf{c''} \gets c - c' $
		\State \textbf{Return} $\mathbf{ZKPExt1((c'',pk),(Dec(c''),s,e,e'))}$
		\EndProcedure
	\end{algorithmic}
\end{algorithm}

\begin{algorithm}
	\caption{Most Significant bit extraction}\label{alg:MSBExtract}
	\begin{algorithmic}[1]
		\Procedure{MSBExtract}{$\mathbf{c}$}
		\State $allOne = \{1,\dots,1\}$
		\State $rot_{c_0} \gets rot(c_0)$
		\State $lwe_0 \gets allOne \times rot_{c_0}[0]$
		\State $rot_{c_1} \gets rot(c_1)$
		\State $lwe_1 \gets allOne \times rot_{c_1}$
		\State \textbf{return} $(lwe_0,lwe_1)$
		\EndProcedure
	\end{algorithmic}
\end{algorithm}

\begin{algorithm}
	\caption{Binary to Unary ciphertext}\label{alg:ToUnary}
	\begin{algorithmic}[1]
		\Procedure{ToUnary}{$\mathbf{c_i}$}
		\For{$j = 0, \dots, l-1$}
		\State let $\mathbf{hd_j} \gets (x^j - 1,0)\times \mathbf{c_j} + (1,0)$
		\EndFor
		\State let $\mathbf{hd} \gets \mathbf{hd_0} \times \mathbf{hd_1} \times \dots
		\times \mathbf{hd_{l-1}}$


		\State \textbf{return} $\mathbf{hd}$
		\EndProcedure
	\end{algorithmic}
\end{algorithm}

\begin{algorithm}
	\caption{ZKPoPK for BV}\label{alg:ZKPBV}
	\begin{algorithmic}[1]
		\Procedure{ZKPBV}{$(\mathbf{c}, pk),(\mathbf{m, s, e, e'}))$}
		\State $rot_{c_1} \gets rot(\mathbf{c_1})$
		\State $rot_{p_1} \gets rot(\mathbf{pk_1})$
		\State let I be the $n \times n$ identity matrix
		\State let Z be the $n \times n $ zero matrix
		\State $\mathbf{A} \gets ((rot_{c_1},-tI, Z, -I),(rot_{p_1}, Z, tI,Z)) $
		\State $\mathbf{x} \gets (\mathbf{s, e', e, m})$
		\State $\mathbf{y} \gets (\mathbf{-c_0, -pk_0})$
		\State \textbf{Return} $\mathbf{SternExt(A,x,y)}$
		\EndProcedure
	\end{algorithmic}
\end{algorithm}

	\begin{algorithm}
	\caption{ZKP for zero constant coefficient}\label{alg:ZKPExt1}
	\begin{algorithmic}[1]
		\Procedure{ZKPExt1}{$(\mathbf{c}, pk),(\mathbf{m, s, e, e'}))$}
		\State $rot_{c_1} \gets rot(\mathbf{c_1})$
		\State $rot_{p_1} \gets rot(\mathbf{pk_1})$
		\State let I be the $n \times n$ identity matrix
		\State let I' be 1 column matrix with all 1s.
		\State let Z be the $n \times n $ zero matrix
		\State let Z' be 1 column matrix with all 0s.
		\State $\mathbf{A} \gets ((rot_{c_1},-tI, Z, -I'),(rot_{p_1}, Z, tI,Z')) $
		\State $\mathbf{x} \gets (\mathbf{s, e', e, m})$
		\State $\mathbf{y} \gets (\mathbf{-c_0, -pk_0})$
		\State \textbf{Return} $\mathbf{SternExt(A,x,y)}$
		\EndProcedure
	\end{algorithmic}
\end{algorithm}

	\begin{algorithm}
		\caption{ZKP for only constant coefficient}\label{alg:ZKPExt2}
		\begin{algorithmic}[1]
			\Procedure{ZKPExt2}{$(\mathbf{c}, pk),(\mathbf{m, s, e, e'}))$}
			\State $rot_{c_1} \gets rot(\mathbf{c_1})$
			\State $rot_{p_1} \gets rot(\mathbf{pk_1})$
			\State let I be the $n \times n$ identity matrix
			\State let I' be I with the first column removed.
			\State let Z be the $n \times n $ zero matrix
			\State let Z' be Z with the first column removed.
			\State $\mathbf{A} \gets ((rot_{c_1},-tI, Z, -I'),(rot_{p_1}, Z, tI,Z')) $
			\State $\mathbf{x} \gets (\mathbf{s, e', e, m})$
			\State $\mathbf{y} \gets (\mathbf{-c_0, -pk_0})$
			\State \textbf{Return} $\mathbf{SternExt(A,x,y)}$
			\EndProcedure
		\end{algorithmic}
	\end{algorithm}

		\begin{algorithm}
		\caption{ZKP of coefficients transform}\label{alg:ZKPUnpack}
		\begin{algorithmic}[1]
			\Procedure{ZKPUnpack}{$\mathbf{c, c'}$}
			\State Let $b_1 \gets \mathbf{ZKPExt1((c-c',pk),(Dec(c-c'), s, e, e'))}$
			\State Let $b_2 \gets \mathbf{ZKPExt2((c',pk),(Dec(c'),s,e,e'))}$
			\State \textbf{Return} $b_1 \land b_2$
			\EndProcedure
		\end{algorithmic}
	\end{algorithm}
\section{Evaluation and Results}
\label{sec:5results}


\label{sec:5combineZKP}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../thesis"
%%% End:
