\chapter{The First Protocol - Computing HD Homomorphically}
\label{chap:firstProtocol}

% **************************** Define Graphics Path **************************
\ifpdf
    \graphicspath{{Chapter3/Figs/Raster/}{Chapter3/Figs/PDF/}{Chapter3/Figs/}}
\else
    \graphicspath{{Chapter3/Figs/Vector/}{Chapter3/Figs/}}
\fi

\section{Introduction}
\label{sec:firstProcIntro}
Many biometrics privacy preserving authentication protocols rely on a trusted
third party to keep the client's secret key used to decrypt the authentication
result \cite{mandal2015comprehensive, hirano2013cryptographically, upmanyu2010blind}. Our first attempt to improve the security of such schemes has
been to remove the role of such a party. As it proves inconvenient, due to
privacy issues, to allow a third party server to keep the client's secret key, the
distance plaintext decryption should be performed by the client, which, in turn,
raises the following challenges:
\begin{description}
\item[Multifactor security] A malicious client with access to the compromised
  secret key of the honest client can derive information about the distance
  between the registered template and the extracted template while he decrypting
  the homomorphic ciphertext result sent by the server.
\item[Malicious Client Model Impact] It is important for the protocol to be secure
  against the \textit{active client }model, by which an adversary does not simply follow the
  protocol transcript but also tries to draw information from it (this model is also known
  as \textit{Semi Honest}, \textit{Honest-But-Curious}, or \textit{Passive} Client Model). 
\end{description}

The first issue has been solved in previous work of
\cite{mandal2015comprehensive} forcing the server to mask the distance between
templates by means of some random value before sending it to the client. In this
chapter, we discuss the solution to the second issue, where a new
Zero-Knowledge-Proof (ZKP) technique for lattice-based cryptosystems is
introduced so as to compel the client to prove that the protocol is followed
honestly. The technique not only provides a proof of plaintext knowledge, it has
another important advantage, it also proves the binary format of the query
template in a way that is compatible with the existing efficient plaintext
packing technique. We can use the ZKP at two stages: When the
client first sends the query in order to start authenticating, and at the final
step, proving that the Hamming Distance is correctly decrypted.


\section{Related Work}
\label{sec:iscRelatedWor}
In a biometric authentication system, a user $\mathcal{U}$ first registers his
biometric template $X$ on the server $\mathcal{S}$. $\mathcal{U}$ later
authenticates to $\mathcal{S}$ using the same finger with a template $Y$,
$\server$ uses an algorithm $Verify(X,Y)$ to obtain the result of the
authentication: \textbf{Accept} or \textbf{Reject}. Different biometric systems
might use different methods to compute the distance $\Delta$ between $X$ and $Y$
within the algorithm $verify$. The distance $\Delta$ is compared to some
predefined threshold value $\tau$ to determine the result of the authentication
trial. We refer the reader to \cite{jain2007handbook} for biometric feature
extraction and comparison techniques. Unlike password based systems, where
$\user$ always uses one and the same query for many authentication trials,
all biometric systems implement the concept of False Acceptance Rate (FAR),
corresponding to the system's \textbf{Accept} answer while receiving an
incorrect template; and False Rejection Rate (FRR), where the system's
\textbf{Reject} answer follows reception of a genuine one.  Balancing these 2
rates while keeping good performances is one of the main challenges that
fingerprint verification algorithms \cite{FVConGoi2:online} try to solve. In
this work, we assume that biometric data are represented as binary codes and
that HD is used to measure the similarity between two of them. We refer the
readers to \cite{daugman2003importance} or \cite{FujitsuD7:online} for examples
of 2048-bit iris code generation and HD comparison.

There are three main approaches for privacy-preserving biometric authentication
(\cite{jain201650}, \cite{belguechi2011overview}, \cite{jain2008biometric}). In
the \emph{Feature transformation approach} (cancelable biometrics or biohashing,
such as \cite{teoh2008cancellable}, \cite{cappelli2010minutia}), the template
data are encrypted using a client's key. Being a single factor protection, it
has a low security level as the key might be leaked. The \emph{Biometric
  cryptosystem approach} (fuzzy vault and fuzzy commitment,
\cite{uludag2004biometric}, \cite{nagar2010hybrid}) is based on error correcting
codes and the trade-off between biometric accuracy and security seems to be
insufficiently understood . We focus our work on the last approach,
\emph{Homomorphic Encryption}, which appears as the best candidate to provide
all of the system design requirements mentioned.

The idea was first proposed in 2006 (\cite{schoenmakers2006efficient}) using the
Paillier addictive homomorphic system (\cite{paillier1999public}). In 2010,
Osadchy et al. (\cite{osadchy2010scifi}) provided a privacy-preserving feature
by combining Paillier system with an oblivious transfer protocol. SCiFI uses
900-bit vector to represent face image data and Hamming Distance (HD) to compare
two vectors. \cite{blanton2011secure} developed a similar system for iris and
fingerprints but using the DGK cryptosystem \cite{damgard2008homomorphic} and
garble circuit technique instead. They represented biometric data as 2048-bit
vectors and also used HD for threshold comparison. \cite{yasuda2014practical}
proposed an approach based on Somewhat Homomorphic Encryption (SHE)
\cite{brakerski2011fully}. They introduced a ciphertext packing technique to
speed up the HD computation operation. There have been variations and
improvements over time (\cite{shahandashti2012private},
\cite{mandal2015comprehensive}, etc.). However, most of the protocols are only
secure against a semi-honest client, many of them relying on one or more trusted
third parties with the client's secret key being used to decrypt the HD.

\begin{table}[]
  \centering
  \caption{Comparison with previous works}
  \label{tab:compare}
  \begin{tabular}{l|c|c|c|c|c|c}
    \cline{2-7}
    & \multicolumn{3}{c|}{\textbf{Client Impersonation Security}} & \multicolumn{3}{c|}{\textbf{Server Privacy Security}}                                                                                                                                                                         \\ \cline{2-7}
    & \begin{tabular}[c]{@{}c@{}}Malicious \\ client \\ model\end{tabular} & \begin{tabular}[c]{@{}c@{}}Stolen \\ device,\\ secret key\end{tabular} & \begin{tabular}[c]{@{}c@{}}Leaked\\ Template\end{tabular} & \begin{tabular}[c]{@{}c@{}}Template \\ protection\\ against server\end{tabular} & \begin{tabular}[c]{@{}c@{}}Trusted \\ party\\ required\end{tabular} & \begin{tabular}[c]{@{}c@{}}Hill \\ climbing\\ protection\end{tabular} \\ \hline
    \cite{dodis2008fuzzy}          & No                                                                   & Yes                                                                    & Yes                                                       & No                                                                              & No                                                                  & No                                                                    \\ \cline{1-1}
    \cite{mandal2015comprehensive} & No                                                                   & No                                                                     & Yes                                                       & No                                                                             & Yes                                                                 & No                                                                    \\ \cline{1-1}
    \cite{shahandashti2012private} & No                                                                   & Yes                                                                    & Yes                                                       & No                                                                             & No                                                                  & Yes                                                                   \\ \cline{1-1}
    \cite{higo2015privacy}         & No                                                                   & Yes                                                                    & Yes                                                       & Yes                                                                             & Yes                                                                 & Yes                                                                   \\ \cline{1-1}
    \cite{vsedvenka2015secure}         & Yes                                                                   & No                                                                    & Yes                                                       & Yes                                                                             & Yes                                                                 & No                                                                   \\ \cline{1-1}
    This paper                       & Yes                                                                  & Yes                                                                    & Yes                                                       & Yes                                                                             & No                                                                  & Yes                                                                   \\ \hline
	\end{tabular}
\end{table}

\section{The BV Cryptosystem and Yasuda Packing Method}
\label{sec:firstProcBGV}
Although the idea of Fully Homomorphic Encryption (arbitrary number of
operations) is feasible, its performance has not been considered practical
enough. We discussed some generic LWE based cryptosystems and their properties in
Section \ref{sub:LWE} of this Chapter. In this Section, we look specifically at BV
cryptosystems, which belong to the Somewhat Homomorphic Encryption type,  and allow
addition and some levels of multiplication (\cite{brakerski2011fully}). In later
chapters of the thesis, an extension of this cryptosystem (namely, BGV
\cite{brakerski2014leveled}) and its variants is used frequently. We here discuss
the basic operations within a BV system, which works
as follows:
\begin{description}
\item[Setup.] Initiate $(n,m,q,t, \chi)$ to define the ciphertext space $R_q = \frac{\mathbb{Z}_{q}[x]}{x^{n} + 1}$,
  the plaintext space $R_t = \frac{\mathbb{Z}_{t}[x]}{x^{n} + 1}$, and the error
  distribution $\chi$ on $\mathbb{Z}_{q}$, for \(t << q\).
\item[KeyGen.] In this step, the secret key $sk$ is chosen by selecting a small element
  $\mathbf{s} \in R_{q}$, $\mathbf{s} \randomsample \chi^{n}$. The public key $pk$ is a pair of ring elements
  $(\mathbf{p}_0,\mathbf{p}_1)$, where $\mathbf{p}_1 \randomsample R_q$ and
  $\mathbf{p}_0 = -(\mathbf{p}_1\mathbf{s} + t\mathbf{e})$ with
  $\mathbf{e} \randomsample \chi^{n}$.
\item[Encryption.] Given a plaintext $\mathbf{m} \in R_t$ and a public key
  $pk=(\mathbf{p}_0,\mathbf{p}_1)$, the encryption first calculates
  $\mathbf{u},\mathbf{f},\mathbf{g} \randomsample \chi$, then computes a fresh
  ciphertext by
    \[
      Enc_{pk}(\mathbf{m}) = (\mathbf{c}_0,\mathbf{c}_1) =
      (\mathbf{p}_0\mathbf{u} + t\mathbf{g} + \mathbf{m},
      \mathbf{p}_1\mathbf{u} + t\mathbf{f})
    \]
    By convention, $\enc{P}$ denotes the encryption of a plaintext $P$ under the
    BV scheme with the public key, and randomness is not taken into
    account. When the noise used in the encryption has to be specified,
    $\enc{(P,e)}$ is used to represent it, $e$ being the noise.
  \item[Decryption.] Although the above encryption generates ciphertexts of 2
    elements only in $R_q$, the homomorphic operations (discussed next) will
    make the ciphertext longer. The decryption of the ciphertext appears as
    $c=(\mathbf{c}_0,\mathbf{c}_1,\dots,\mathbf{c}_L)$, with secret key
    $sk = (1, \mathbf{s}, \mathbf{s}^2,\dots, \mathbf{s}^L)$ as
    $ Dec(\mathbf{c},sk) = \left[\left[ \langle \mathbf{c}, \mathbf{sk} \rangle
      \right]_Q \right]_t $.
  \item[Homomorphic Operations.] Given 2 ciphertexts
    $c = (\mathbf{c}_0,\mathbf{c}_1,\dots,\mathbf{c}_L)$ and
    $c' = (\mathbf{c}'_0,\mathbf{c}'_1,\dots,\mathbf{c}'_K)$, before any
    operations are carried out, the ciphertexts are padded with zeros first if
    necessary (to make $K = L$, assuming that, initially, $K < L$).  The
    homomorphic addition $add(c,c')$ is computed by the component-wise addition
    $add(c,c') = (\mathbf{c}_0 +\mathbf{c}'_0, \dots,
    \mathbf{c}_L+\mathbf{c}'_L)$. The homomorphic multiplication $mult(c,c')$ is
    computed by
    $mult(c,c') = (\mathbf{\hat{c_0}}, \mathbf{\hat{c_1}}, \dots,
    \mathbf{\hat{c}_{2L-2}})$ with
    $ \sum_{i=0}^{2L-2}\mathbf{\hat{c}_i}z^i = \sum_{i=0}^{L-1}\mathbf{c_i}z^i
    \times \sum_{j=0}^{L-1}\mathbf{c'_j}z^j $, where $z$ denotes a symbolic
    variable.
\end{description}

\subsection{Ciphertext packing}
\label{sub:ciphertext_packing}
Given a bit string plaintext $m \in \{0,1\}^*$, there are several ways to encode
it as a polynomial, or a ring element \textbf{m} $\in$ R$_{t}$ before
encryption. A recent popular approach for BV cryptosystems is the so-called CRT
packing method, based on the Chinese Remainder Theorem
\cite{smart2014fully}. The method allows Single Instruction, Multiple Data
(SIMD) operations on encrypted data. However, we do not use this packing
technique in this chapter as it involves some complications unrelated to the
main point of this chapter (later, in chapter \ref{chap:fourthProtocol}, we
propose a different approach to packing methods). This chapter focuses on the
method of \cite{yasuda2014practical}, which is an extension of
\cite{naehrig2011can}, the technique allowing HD computation with just one level
of multiplication.

Biometrics are used in authentication as the human features they record
systematically differ from one person to another. There are many algorithms that
extract the data used in the process (\cite{FVConGoi2:online}) (we refer to this
data as "biometric templates"). Many works (such as \cite{daugman2003importance}
and \cite{FujitsuD7:online}) use Hamming Distance (HD) as the metrics to measure
the similarity of the stored and query templates, and we equally do so to
evaluate our hypothesis (\ref{protocol:step3}). In the work of
\cite{yasuda2014practical}, the authors propose an innovative to compute the HD
of two n-bits templates $X$ and $Y$ in the ciphertext domain. Specifically, the
method packs all the bits of a template into a single ciphertext, and a linear
combination of homomorphic operations would purveys an HD result. We sketch
their method below.
\begin{definition} [\cite{yasuda2014practical}]
  For $\mathbf{T} = (t_0, \dots, t_{n-1}$ and
  $\mathbf{Q} = (q_0, \dots, q_{n-1})$, we define two types of polynomials in
  the ring $R_q$ of the SHE scheme:
  \[
    pm_1(\mathbf{T}) = \sum_{i=0}^{n-1}t_ix^i \ \textnormal{and} \
    pm_2(\mathbf{Q}) = - \sum_{j=0}^{n-1}q_jx^{n-j}
  \]
  The two types of packed ciphertexts are defined as
  \[
    ct_{1}(\mathbf{T}) = Enc(pm_1(\mathbf{T})) \ \textnormal{and} \
    ct_{2}(\mathbf{Q}) = Enc(pm_2(\mathbf{Q}))
  \]
\end{definition}
The main idea of \cite{yasuda2014practical} is that, if in the ring $R_q$ where
$x^n = -1$, then, when multiplying $pm_1(\mathbf{T})$ by $pm_2(\mathbf{Q})$, the
constant term of the result will be the inner product
$\langle \mathbf{T}, \mathbf{Q}\rangle$. If homomorphic multiplication is
applied to the ciphertexts, the ciphertext of their inner product will similarly
show as a result of it. Furthermore, this result can be used to compute HD as
shown below, the operation costs being one level of multiplication with 3
additions and 3 multiplications on ciphertexts.

\begin{theorem}
  Let $C_1 = - \sum_{i=0}^{n-1}x^{n-i}$ and
  $C_2 = 2 - C_1 = \sum_{i=0}^{n-1}x^i$. Let $Enc(HD)$ be a ciphertext given by
  \[
    ct_1(\mathbf{T})*Enc(C_1) + ct_2(\mathbf{Q})* Enc(C_2) -
    2*ct_1(\mathbf{T})*ct_2(\mathbf{Q})
  \]
  Then, the constant term of $Dec(Enc(HD))$ gives the Hamming Distance of
  $\mathbf{T}$ and $\mathbf{Q}$.
\end{theorem}

\begin{algorithm}
\caption{HD Computation Homomorphically}\label{alg:EvalDistance}
\begin{algorithmic}[1]
\Procedure{EvalDistance}{$\mathbf{T,Q}$} 
\State $C_1 \gets - \sum_{i=0}^{n-1}x^{n-i}$
\State $C_2 \gets 2 - C_1$
\State $C_{HD} \gets ct_1(\mathbf{T})*Enc(C_1) + ct_2(\mathbf{Q})*
Enc(C_2) - 2*ct_1(\mathbf{T})*ct_2(\mathbf{Q})$
\State \textbf{return} $C_{HD}$
\EndProcedure
\end{algorithmic}
\end{algorithm}

\section{Zero-knowledge proof system}
\label{sec:introzkp}
Suppose that \emph{Paul} has found a solution
to a hard problem and he wants to convince \emph{Vicky} that the problem has
been solved by him. \emph{Paul} can simply write out the solution and give it
to \emph{Vicky}. However, \emph{Vicky} could be as
dishonest as to show the solution to others and claim that
it was her who solved the problem. The Zero Knowledge Proof (ZKP) is a
beautiful cryptographic concept allowing \emph{Paul} to produce the proof
in such a way that \emph{Vicky} does not learn any information besides the 
fact that the problem has been solved. Since introduced
in the 80s \cite{goldwasser1989knowledge}, ZKP has been extensively
studied and is currently an important building block of many cryptographic
protocols: identification schemes ( \cite{fiat1986prove, feige1988zero, guillou1990paradoxical, schnorr1991efficient, stern1993new, kawachi2008concurrently},\dots), group signatures(
\cite{camenisch1997efficient, ateniese2000practical, boneh2004short, boneh2004group, groth2007fully}\dots),
anonymous credential systems ( \cite{camenisch2008efficient},
\cite{camenisch2001efficient}, \cite{belenkiy2009randomizable},
\cite{chase2013malleable},\dots), interactive encryption protocols(
\cite{galil1985symmetric}, \cite{goldreich2009foundations},
\cite{goldwasser2005proof}, \cite{katz2003efficient},\dots), and many more. 

In this chapter, we discuss zero-knowledge proofs of plaintext knowledge for
LWE-based cryptosystems. Given a system with a public key $\pk$, a proof of
plaintext knowledge (PoPK) allows a $Prover$ P to convince a $Verifier$ V that
it knows the plaintext $M$ of some ciphertext $c = Enc(\pk, M)$. The witness
used in the proof normally consists of the plaintext, the secret key, and the
randomness factor implemented during encrypting $c$. A PoPK system is
zero-knowledge in the sense that it does not allow V to acquire any information
about $M$. This research area has received attention in recent years. A ZKPoPK
for a variant of the Ajtai-Dwork system \cite{ajtai1997public} was engineered by
\cite{goldreich1999approximating}, who adapted the protocol from
\cite{micciancio2003statistical}. Xagawa and Tanaka \cite{xagawa2009zero} used
the Stern-KTX proof \cite{stern1993new, kawachi2008concurrently} to obtain PoPK
for NTRU cryptosystems \cite{hoffstein1998ntru}. Many projects targeted Regev's
LWE-based cryptosystem (\cite{bendlin2010threshold, bendlin2011semi,
  asharov2012multiparty}, but they all derived from a secure Multi-Party
Computation protocol, specifically the IKOS transformation \cite{ishai2007zero},
and therefore had a relatively high communication cost. 




% At a simplified high level, the system works by evaluating the Hamming Distance (HD) between the encrypted biometric
% query and encrypted registered biometric homomorphically on the server using the SWHE, sending the encrypted HD back to
% the client for decryption and letting the client send back the decrypted HD to the server for comparing with a threshold
% . To secure the protocol against a malicious client, we add appropriate
% Zero-Knowledge (ZK) Proofs of Knowledge by the client to convince the server that the client has done the correct
% computations. However, achieving this goal efficiently is not trivial for the following reasons.

% First, for efficiency, the Yasuda protocol needs to use plaintext packing techniques (\cite{yasuda2014practical}), and we need to design new ZK
% proofs for the approporiate relations to support this packing. As our first technical contribution, we show how to adapt
% the Stern ZK proofs to obtain suitable ZK proofs for our protocol. (add more info?)

% Second, due to the noise inherent inside lattice-based homomorphic encryption and its correlation with the
% homomorphicaly evaluated plaintexts (the registered template) it turns out the above simplified version of our protocol
% may leak information on the registered template to a two-factor malicious impersonating client that has access to the
% victim client's secret key, i.e. we observe that is not enough for the server to mask the HD plaintext with a random
% one-time-pad mask before sending the ciphertext to the client (as done also in [Yasuda]; the noise in the ciphertext
% must also be masked. Unfortunately, a perfect one-time-pad mask cannot be used for the noise as it must be `small' for
% decryption. A similar problem has been observed in theoretical studies of circuit privacy of lattice-based secure
% computation protocols~\cite{circuit privacy}, but those solutions yield inefficient protocols. As our second technical
% contribution, we show a new application of Renyi divergence based analysis~cite{RD} to show the malicious security of
% our protocol with a small `imperfect' one-time pad. To do so efficiently, we show how to extend previous technical
% bounds on Renyi divergence between a discrete Gaussian and its offset in for Renyi divergence of order 2 to the case of
% Renyi divergene of order infinity.

\subsection{Stern-based ZKP}
\label{sec:Stern-basedZKP}
Recall that we need to construct a proof for the ISIS relation:
\[
  R_{ISIS_{n,mq,\beta}} = \{ ((\mathbf{A},\vec{y}),\vec{x})
  \in \mathbb{Z}_q^{n\times m} \times \mathbb{Z}_q^n
  \times \mathbb{Z}^m: (\|\vec{x}\|_\infty \leq \beta) \land
  (\mathbf{A}\vec{x} = \vec{y} \mod q) \}
\]
There are several approaches to construct such a proof (e.g. \cite{lyubashevsky2008lattice},
\cite{micciancio2003statistical}, \cite{stern1993new}). We here discuss an approach based on \cite{stern1993new}. We refer our readers to the original paper for the detailed steps of the protocol and denote the whole proof protocol
\(\mathbf{Stern}_{A,x,y}\). It can be applied to implement a Zero Knowledge Proof of
Plaintext Knowledge (ZKPoPK) for latticed-based cryptosystems. For example, an extension of the work of \cite{ling2013improved}  (denoted by \(\mathbf{SternExt}\)), allows to compute plaintext knowledge by proving the encryption relation
of Regev's cryptosystem \cite{regev2009lattices}:

\begin{equation*}
  \label{eq:regev_zkp}
  \begin{multlined}[][\LTcapwidth]
    R_{Regev}^{q,m,n,t,\chi} = \{ ((p_0,p_1),(c_0,c_1),\vec{r}||M) \in (\mathbb{Z}_q^{m \times n} \times
    \mathbb{Z}_q^{m})
    \times (\mathbb{Z}_q^n \times \mathbb{Z}_q) \times \mathbb{Z}_q^{n+1} : \\
    (c_0 = p_0\vec{r}) \land (c_1 = p_1\vec{r} + M) \}
  \end{multlined}
\end{equation*}

The proof works by letting $\mathbf{A'} = \begin{bmatrix} p_1, 1\\p0, 0
\end{bmatrix} $ and $\mathbf{y} = \begin{bmatrix} c_1\\c_0
\end{bmatrix}$ be the public parameters and by letting $\mathbf{x} =
\begin{bmatrix}
  \vec{r}\\M
\end{bmatrix}$ be the \emph{Prover}'s witness. We observe that $\mathbf{A'} \mathbf{x} = \mathbf{y} \mod q$, that is,
$\mathbf{x}$, is a solution to the ISIS problem, provided that $\norminf{\vec{r}} \approx |M|$ AND the \emph{Prover} within a symmetric key setting. In many other contexts, the client does not know
$\vec{r}$, as encryption is ensured by other parties using public keys. For such situations, we can look at the decryption
equation:
\begin{align*}
  c_1 - c_0\vec{s} &= p_1\vec{r} + M - p_0\vec{r}\vec{s} \\
                   &= \mathbf{A}\vec{s}\vec{r} + t\vec{e}\vec{r} + M - \mathbf{A}\vec{r}\vec{s}\\
                   &= t\tilde{e} + M
\end{align*}
We denote $S_{1}, S_{2}, S_{m}$ to be subsets of $\mathbb{Z}_{q}$ corresponding to small coefficients of $\mathbf{s}, \mathbf{e}, \mathbf{m}$
Therefore, we can write out the decryption relation as:
\begin{equation*}
  \begin{multlined}[][\LTcapwidth]
    R_{Regev,dec}^{q,m,n,t\chi} = \{((p_0,p_1),(c_0,c_1),\vec{s},\vec{e},\tilde{e}, M) \in (\mathbb{Z}_q^{m \times n}
    \times \mathbb{Z}_q^{m})\times (\mathbb{Z}_q^n \times \mathbb{Z}_q)\times S_{1}^n \times S_{2}^n \times S_{m} \times
    \zzq:\\ (p_1 = p_0\vec{s} + t\vec{e}) \land (c_{1} = c_{0}\vec{s} + t\tilde{e} + M) \}
  \end{multlined}
\end{equation*}
Similarly, we can let $\mathbf{A}_{Stern} = \begin{bmatrix} c_0, t, 0, 1\\p_0, 0, t, 0
\end{bmatrix}$ (the public parameters) and let \(\mathbf{X}_{Stern} = [\vec{s},\tilde{e},\vec{e},M]^T\) and try applying \textbf{SternExt} to obtain the ZKPoPK. However, this will not work because the original
solution proves that $\norminf{\mathbf{X}_{Stern}} <
\beta$. In such cases, we want to prove the bound of separate components differently: in our above example,
$\norminf{\tilde{e}} >
\norminf{\vec{e}}$. In a Regev cryptosystem, the problem might not be clear enough, as the norms of each vector in
$\mathbf{X}_{Stern}$ are quite close to each other. In other latticed-based system, the difference can be big, as for example, the BV system's decryption relation:
\begin{equation*}
  \begin{multlined}[][\LTcapwidth]
  R_{BV}^{q,n,t,\chi} = \{((\mathbf{c}_0, \mathbf{c}_1),(\mathbf{p}_0, \mathbf{p}_1), \mathbf{s},\mathbf{e}', \mathbf{e}, \mathbf{m} \in
  (\rrq \times \rrq) \times (\rrq \times \rrq)  \times S_{1}^n \times S_{2}^n \times S_{2}^n \times S_{m}:\\
  (\mathbf{p}_1\mathbf{s} + t\mathbf{e} = -\mathbf{p}_0 ) \land (\mathbf{c}_1\mathbf{s} - t\mathbf{e}' -\mathbf{m} = -\mathbf{c}_0)
  \}
  \end{multlined}
\end{equation*}

Our \emph{Prover}'s witness in this situation is
\(\mathbf{X}_{Stern} = [\mathbf{s, e', e, m}]^{T}\) with
$\norminf{s} \approx \norminf{e} > \norminf{e'} >> \norminf{m}$.  Therefore,
instead of proving $\norminf{\mathbf{X}_{Stern}} < \beta$, we need a proof with
different constraints on the witness' components. In particular in our
application, we need to prove that the message has binary coefficients (for
correctness of the Hamming Distance homomorphic computation), whereas the errors
have non-binary coefficients. We present a solution for this problem.
\subsubsection*{Our construction}
% There are several requirements need to be
% satisfied:
\begin{description}
% \item The Stern protocol leaks the Hamming Weight of the witness, we can cover this
%   leakage by using some kind of padding technique: to make sure that the number of 0s and
%   1s in the message must be equal to each other
% \item we can also apply the decompose technique of \cite{ling2013improved} in
%   each of the elements of the prover witness.
\item [The idea.] is that, instead of
  proving $\norminf{x_i} < \beta_i$, or proving that all the coefficients of $x_i$ are in the range $\{-\beta_i, \dots, \beta_i\}$, it can also be proved that $x_i + \beta_i.f(x)$ is in the range $\{0, \dots, 2\beta_i\}$, where
  $f(x) = 1 + x + x^2 + \dots + x^{n-1}$. Secondly, if we decompose \(x_{i} + \beta_{i}.f(x)\) to its binary
  representation and apply the Stern's variant of \cite{kawachi2008concurrently} to prove the relation

  \begin{equation*}
    \begin{multlined}[][\LTcapwidth]
      R_{KTX} = \{\mathbf{((A,y),x)} \in \mathcal{Z}_{q}^{n \times m} \times \mathcal{Z}_{q}^{n}\times \{0,1\}^{m}:
      wt(\mathbf{x}) \wedge \mathbf{A . x = y} \mod q\},
    \end{multlined}
  \end{equation*}

  the proof for the original relation \(R_{BV}^{q,n,t,\chi}\) can be
  obtained. Note that, at this point the $Prover$'s witness is a binary vector,
  that is, if it needs to be to proved that some part of the message is binary,
  such a proof can be obtained at this point as well. It is important to use
  such a proof for latticed-based cryptosystems where the message space is
  $\mathbf{R}_2$: a proof for the ISIS relation would not be suitable in such
  situations, as it only asserts that the infinity norm of the whole witness is
  less than some $\beta$.

\item [Protocol description.]
  The protocol \textbf{SternBV(A,y,x)} works as follows: Let $A$ be a matrix of $m \times l$ ring element ($A \in R_{q}^{m \times l}$),
  $\mathbf{x}$ be a vector of $l$ ring elements $\mathbf{x} = \left\{ \mathbf{x}_1, \mathbf{x}_2, \dots, \mathbf{x}_l \right\}$ and
  similarly $\mathbf{y} = \left\{ \mathbf{y}_1,\dots,\mathbf{y}_m \right\}$. The protocol includes the following steps:

\item [Step 1.] Normalizing the bound of each component $x_i$ of \textbf{x} from
  $\{-\beta_i,\dots,\beta_i\}$ to $\{0,\dots,2^{l_i}\}$, where $l_i$ is the
  smallest integer satisfying $2^{l_i} > (2\beta_i -1)$. This step is done by
  one ring multiplication for each $\mathbf{x}_i$, let
  $\mathbf{x}_i' = \mathbf{x}_i + \beta_i.\mathbf{f}(x)$, where
  $\mathbf{f}(x) = 1 + x + x^2 + \dots + x^{n-1}$. After this normalization step, instead
  of proving the relation $\sum_{j}\mathbf{a}_{i,j} \mathbf{x}_j = \mathbf{y}_i$ with
  $\norminf{\mathbf{x}_i} \in \left\{ -\beta_i, \dots, \beta_i \right\}$, we prove
  $\sum_{j}\mathbf{a}_{i,j} \mathbf{x}'_j = \mathbf{y}'_i$ with
  $\norminf{ \mathbf{x}'_i } \in \left\{ 0,\dots,2^{l_i} \right\}$, where
  $\mathbf{y}'_i = \sum_{j}\mathbf{a}_{i,j}\beta_j \mathbf{f}(x)$.

\item [Step 2.] Decompose $\mathbf{x}'_i = \mathbf{x}_i + \mathbf{\beta}_i$ into their binary representation
  \[
    \mathbf{x}''_i = \sum_{j = 0}^{l_i -1}{2_j b_j}
  \]
  Let $\mathbf{x}''$ be the result ring element that concatenates all $\mathbf{x}''_i$ and has $L = \sum{l_i}$
  coefficients. In this step we need to hide the Hamming Weight of the secret vector $\mathbf{x}'_i$. This hiding task
  is achieved by padding:
  \begin{enumerate}
  \item Let $\zeta_0$ and $\zeta_1$ be the number of coefficients of $\mathbf{x}''$ equal to 0 or 1, respectively.
  \item Sample a random vector $\mathbf{\zeta} \in \left\{ 0,1 \right\}^{L}$ that has $(L - \zeta_0)$ coefficients 0 and
    $(L - \zeta_1)$ coefficients 1.
  \item Output $\mathbf{x_{Stern}} = \mathbf{x}'' || \mathbf{\zeta}$.
  \end{enumerate}
  The resulting binary vector $\mathbf{x_{Stern}}$ has length $2L$ and the total number of 0s and 1s in the
  $\mathbf{x_{Stern}}$ are the same.

\item [Step 3.] We denote $ rot({\textbf{c}}) \in \mathbb{Z}_Q^{n\times n}$ to be an anti-circulant square matrix, whose
  first column is $\mathbf{c}$, the remaining columns of it being the cyclic rotations of $\mathbf{c}$ with the cycled entries
  negated
  \[
    rot({\mathbf{c}})=
    \begin{bmatrix}
      c_0 & -c_{n-1} & -c_{n-2} & \dots\\
      c_1 & c_0 & -c_{n-1} & \dots\\
      \dots & \dots & \dots & \dots\\
      c_{n-1} & c_{n-2} & c_{n-3} & \dots
    \end{bmatrix}
  \]
  The matrix $A$ can be then reconstructed as $rot$ matrices:
  \[
    \forall \mathbf{a}_{i,j} \in \mathbf{A}: \mathbf{a}'_{i,j} =
    rot(\mathbf{a}_{i,j})
  \]
  The result expanded matrix is denoted $\mathbf{A'}$. We also need to pad the
  resulting matrix with a corresponding number of 0s to make sure that
  $\mathbf{A'}$ complies with all $x'_i$. Let $\mathbf{A_{Stern}}$ be the padded
  result.

\item [Step 4.] Modify $\mathbf{y}_i$: Let
  $\mathbf{y}'_i = \sum_{j}\mathbf{a}_{i,j}\mathbf{\beta}_{j}\mathbf{f}(x)$ and
  let $\mathbf{y_{Stern}}$ be the concatenation of all $\mathbf{y}'_i$.


\item [Step 5.] Run the Stern protocol (Section \ref{append:Stern}) for the proof of $\mathbf{A_{Stern}x_{Stern} = y_{Stern}}$.

\item [Result.] Our protocol has the following properties:
  \begin{itemize}
  \item The knowledge extractor produces different $x_i$ with
    $\norminf{x_i} \leq \beta_i$. Inheriting from the original Stern protocol,
    the extraction gap is $\gamma = 1$. In other words, if the prover $P$ has a
    valid witness for the relation and it follows the protocol, then it is
    always accepted by the verifier $V$, the proof system has perfect
    completeness
  \item The communication cost is $2(n\log q){\sum{l_i}} + commitmentSize$ for
    each round.
  \item The Statistical Zero-Knowledge property can be proved by adapting the
    technique from \cite{stern1993new, kawachi2008concurrently} to construct a
    simulator $S$ which has black-box access to a cheating verifier $\hat{V}$:
    on inputs $\mathbf{A_{stern},y_{stern}}$, outputs an accepted transcript
    with probability $2/3$. Additionally, the $view$ of $\hat{V}$ in the
    simulation should be statistically close to the view of the verifier in the
    real situation.

  \end{itemize}

\end{description}

  \begin{algorithm}
    \caption{ZKPoPK Improved for BV}\label{alg:ZKPBVImproved}
    \begin{algorithmic}[1]
      \Procedure{ZKPBV}{$(\mathbf{c}, pk),(\mathbf{m, s, e, e'}))$}
      \State $rot_{c_1} \gets rot(\mathbf{c}_1)$
      \State $rot_{p_1} \gets rot(\mathbf{pk}_1)$
      \State let I be the $n \times n$ identity matrix
      \State let Z be the $n \times n $ zero matrix
      \State $\mathbf{A} \gets
      \begin{bmatrix*}
        rot_{c}, -tI, Z, -I\\
        rot_{p_{1}}, Z, tI, Z
      \end{bmatrix*}
$
      \State $\mathbf{x} \gets (\mathbf{s, e', e, m})$
      \State $\mathbf{y} \gets (\mathbf{-c_0, -pk_0})$
      \State \textbf{Return} $\mathbf{SternExt(A,x,y)}$
      \EndProcedure
    \end{algorithmic}
  \end{algorithm}


\section{Our Protocol}
\label{sec:our_protocol}

\subsection{The protocol specification}
\label{sec:protocol1specs}

We denote $\user$ to be the client and $\server$ to be the server. There are 3
main submodules in the protocol: Setup, Enrol, and Authenticate. Figure \ref{fig:firstProtocol} illustrates the protocol transcript.
\begin{description}
\item[Setup.] $\user$ and $\server$ initialize the parameters, taking into account the following categories:
  \begin{description}
  \item[Biometric Authentication System Parameters.] These parameters are standard ones used by non privacy preserving
    biometric authentication systems:
    \begin{itemize}
    \item False Acceptance Rate (FAR) and False Rejection Rate (FRR)
    \item $a$: The maximum number of incorrect authentication attempts allowed by $\server$.
    \item $\tau$: Threshold to compare the Hamming Distance to decide the authentication result.
      % \item $B$: An integer defines the base of the HD in a
      %   decomposition operation.
    \item \(n'\): The bit-length of the encoded
      biometric data.
    \end{itemize}
  \item[Ring-LWE based techniques parameters.] These parameters are used in the lattice-based cryptosystem which provides
    client privacy against long term quantum attacks.
    \begin{itemize}
    \item $\lambda$: General security parameter of the cryptosystem (the adversary's winning chance in the CPA security game is \(1/2^{\lambda}\))
    \item $n$: Integer $n$ defining the plaintext and ciphertext rings. This will be referred to as the degree of
      the polynomial objects or dimension of the underlying lattice during correctness and security proofs.
    \item $t$: Integer $t$ defining the plaintext space ring $R_t = \mathbb{Z}_t[x]/x^n+1$.
    \item $q$: Integer $q$ defining the ciphertext space ring $R_q = \mathbb{Z}_q[x]/x^n+1$
    \item $\chi_{\alpha q}$: A distribution used to sample noises for LWE-based techniques.  Typically, $\chi$
      is a discrete Gaussian distribution with standard deviation $\alpha q$ (Section \ref{sub:q-ary lattices and SIS problem}).
    \end{itemize}
  \item[Keygen.] Keys are generated for $\user$:
    \begin{itemize}
    \item Secret key: $\mathbf{s} \randomsample \chi_{\alpha q}^n$, \(sk = (1, \mathbf{s, s^{2}, ...})\)
    \item Public key: $pk = (\mathbf{p}_0,\mathbf{p}_1)$, with $\mathbf{p}_1 \randomsample R_q$ and
      $\mathbf{p}_0 = -\mathbf{p}_1\mathbf{s} - t\mathbf{e}$, with $\mathbf{e} \randomsample \chi_{\alpha q}^n$.
    \end{itemize}
  \end{description}
\item [Enrolment.] $\user$ extracts the biometric template $\mathbf{x}$, the bit string $\mathbf{x}$ being
  represented as a ring element of ${R}_t$.  The encryption is done by $\enc{\mathbf{x}} = (\mathbf{c}_0,\mathbf{c}_1)$
  and sent to $\server$.
\item [Authentication.] The following steps are required:
  \begin{enumerate}
  \item $\user$ extracts his biometric features again $\mathbf{y}$ to use them as the query. $\user$ sends
    $\enc{\mathbf{y}} = (\mathbf{c}_0', \mathbf{c}_1')$ to $\server$.
  \item ZKP for the first relation: $\user$ has to prove that $\enc{\mathbf{y}}$ is a valid encryption, that is, it
    encrypts a bit string under the BV cryptosystem using the corresponding secret key. This is done by module
    \textbf{SternBV(A, y, x)} described in Sect. \ref{sec:Stern-basedZKP}, where
    $\mathbf{A} = \begin{bmatrix} c_{y0}, t, 0, 1\\p_{y0}, 0, t, 0
    \end{bmatrix}$, \(\mathbf{x} = [\vec{s},\tilde{e_{y}},\vec{e_{0}},y]^T\) and \(\mathbf{y
    = [c_{y1},p_{y1}]}^{T}\).

\item HD Computation: $\server$ computes $\enc{HD_{\mathbf{x,y}}}$ using
  procedure \textbf{EvalDistance} \ref{sub:ciphertext_packing} and mask $HD$ by adding some random
  value $r$ homomorphically to $\enc{HD_{\mathbf{x,y}}}$. The result
  $\enc{\mathbf{HD}'} = \enc{HD_{x,y}} + \enc{r}$ is then sent to $\user$.
\item \(\user\) decrypts $\enc{\mathbf{HD}'}$ and derives the actual value
  ${HD'}$ from the first coefficient of the plaintext:
  \( dec\enc{\mathbf{HD}'} = HD' + r_1 + r_2 + \dots + r_{n-1} \). \(\user\)
  sends \(HD' \in \mathbb{Z}\) to \(\server\).
\item \(\user\) proves that it does the decryption honestly, this is done
  similarly to step 2.
\item \(\server\) unmasks \(HD'\) (by computing $HD'' = HD' - r$) and outputs the authentication result
  \(HD \stackrel{?}{<} \tau\)
  \end{enumerate}

\end{description}

\begin{figure}[htbp!] 
  \centering \procedure{THE FIRST PROTOCOL}{
    \textbf{Client} \> \> \textbf{Server}\pclb
    \pcintertext[dotted]{Enrolment}\\
    \text{Extract } \mathbf{x} \randomsample D_k \> \> \\
    \mathbf{\enc{x}} = Enc(\mathbf{x},\pk) \> \sendmessageright*{\enc{\mathbf{x}}}
    \> \text{Persist $\enc{\mathbf{x}}$}\pclb
    \pcintertext[dotted]{Authentication}\\
    \text{Extract } \mathbf{y} \randomsample D_k \> \> \\
    \mathbf{\enc{y}} = Enc(\mathbf{y},\pk) \> \sendmessageright*{\enc{\mathbf{y}}}
    \> \\
    \> \sendmessageright*{\mathbf{ZKPoPK1}} \> \mathbf{\enc{HD}} = EvalDistance(\mathbf{\enc{x},\enc{y}}) \\
    \> \> \mathbf{r} \randomsample \mathbb{Z}_{HD}\\
    \> \> \mathbf{\enc{HD'}} = \mathbf{Add(\enc{HD}, \enc{r})}\\
    \> \sendmessageleft*{\mathbf{\enc{HD'}}} \> \\
    HD' + r_1 + \dots + r_{n-1} = Dec(\enc{\mathbf{HD'}}, \sk) \> \> \\
    \> \sendmessageright*{HD'} \>\\
    \> \sendmessageright*{\mathbf{ZKPoPK2}} \> HD = HD' - r\\
    \> \sendmessageleft*{\mathbf{Accept|Reject}}\> HD \stackrel{?}{<} \tau
  }
  \caption{The First Protocol}
  \label{fig:firstProtocol}
\end{figure}

\subsection{Correctness and Security}
\label{sec:protocol1CorrectnessSecurity}

\subsubsection{Correctness}
\label{sec:correctness}
In the enrolment step, as mentioned before, in order to encrypt $\mathbf{x}$,
$\user$ samples $\mathbf{u,f,g} \randomsample \chi_{\alpha q}^n$ and does
$\mathbf{c}_0 = \mathbf{p}_0\mathbf{u} + t\mathbf{f} + \mathbf{x}$ and
$\mathbf{c}_1 = \mathbf{p}_1\mathbf{u} + t\mathbf{g}$. The condition for decryption
correctness is $[\langle \mathbf{c}_0 + \mathbf{c}_1\mathbf{s} \rangle]_q < q/2$, or,
$-t\mathbf{eu} + t\mathbf{f} + t\mathbf{gs} < q/2$.

In the authentication step, \(\enc{HD}\) is decryptable if
\(\norminf{\langle \enc{HD}, \mathbf{s} \rangle} < q/2\), if we let \(U\) to be
the upper bound of \(\norminf{\langle \enc{HD}, \mathbf{s} \rangle}\), and
considering that \(\norminf{a + b} \leq \norminf{a} + \norminf{b}\) and
\(\norminf{a.b} \leq n.\norminf{a}.\norminf{b}\). From theorem
~\ref{theo:HDComputation}, we can derive
\(\norminf{\langle \enc{HD},\mathbf{s} \rangle} \leq 2nU + 2nU^{2}\). As in the
work of \cite{naehrig2011can}, we can take \(U\) to be
\(2t \sigma^{2} \sqrt{n}\), which is an experimental estimation. Therefore, the
final correctness condition for authentication is
\( 16n^{2}t^{2}\sigma^{4} < q\).
\begin{lemma}[Condition for Correct Decryption of HD]
  \label{le:hdcorrectness}
 For the BV encrypted Hamming Distance \(\enc{HD}\), the decryption recovers the correct result if \(\langle \enc{HD},
 \mathbf{s} \rangle\) does not wrap around mod q, namely, if \(16n^{2}t^{2}\sigma^{4} < q\).
\end{lemma}

\subsubsection{Security}
\label{sec:securityPro1}
The proposed scheme satisfies the security notions defined in Section \ref{sec:syntaxModel}
\begin{theorem}[Server side security]
  \label{theo:serverPro1}
  Under the IND-CPA security of BV cryptosystems, and the zero-knowledge property of the Stern protocol, the proposed
  scheme satisfies (Honest But Curious) Server Privacy Security.
\end{theorem}


The proof of Theorem \ref{theo:serverPro1} can be obtained using a sequence of games
between a challenger $\challenger$ and an adversary $\attacker$. We present a
sequence of games below. The idea is to remove $sk_k$ and $X_k$ from being used
to compute the view of $\attacker$, except for $Verify(X_k,Y_k^{j})$ queries, as
in the ideal game, relying on the correctness of the protocol and the IND-CPA
security of the BV encryption scheme and the zero-knowledge property of the ZKP
simulator.

\textit{Game 0} (Figure \ref{fig:game0protocol1server}). Game 0 is the original real privacy game, in which
$\enc{\mathbf{X}_{k}} = Enc(\mathbf{X}_{k},\pk)$ is given by $\challenger$ to
$\attacker$ at the beginning of the game. Then, for $j=1\ldots,q$, the attacker
sends $Y_i \in \{0,1\}^n$ to $\challenger$, and the latter simulates a run
of the authentication protocol between an honest client with input
$(k,Y_i, sk_k)$ and an honest server with input $(k,\enc{\mathbf{X}_{k}})$, returning to
$\attacker$ the protocol's view $V^{(i)}_S$ of the server. Finally, $\attacker$
outputs a bit $\beta$. In the following Game $j$, we let $S_j$ denote the event
that $\beta=1$.

\begin{figure}[htbp!] 
  \centering
  \fbox{
   \begin{gameproof}[nr=-1]
  \gameprocedure[linenumbering, mode=text]{
    $D_{k} \randomsample D_{bio}$\\
    $(\sk, \pk) \gets KeyGen$\\
    $\mathbf{X}_{k} \randomsample D_{k}$\\
    $\enc{\mathbf{X_{k}}} \gets Enc(\mathbf{X}_{k},\pk)$\\
    For $i=1,\dots,q$:\\
    $\mathbf{Y}_{i} \gets \{0,1\}^{n}$\\
    $\enc{\mathbf{Y}_{i}} \gets Enc(\mathbf{Y}_{i},\pk)$\\
    $verifierView1 \gets \mathbf{ZKPoPK1}((\sk,\mathbf{Y}_{i});(\pk,\enc{\mathbf{Y}_{i}}))$\\
    $\enc{\mathbf{HD}_{i}} = EvalDistance(\enc{\mathbf{X}_{k}},\enc{\mathbf{Y}_{i}})$\\
    $r_{i} \randomsample \mathbb{Z}_{HD}$,$\enc{\mathbf{HD'}_{i}} = Add(\enc{\mathbf{HD}_{i}},\enc{r_{i}})$\\
    $HD'_{i} \gets Dec(\enc{\mathbf{HD'}_{i}},\sk)$\\
    $verifierView2 \gets \mathbf{ZKPoPK2}((\sk,\mathbf{HD'}_{i});(\pk,\enc{\mathbf{HD'}_{i}}))$\\
    $HD_{i} \gets HD'_{i} - r_{i}$\\
    $res_{i} \gets compare(HD_{i}, \tau)$\\
    $\beta \gets \adv(verifierView1, verifierView2, \enc{\mathbf{X}_{k}}, \enc{\mathbf{Y}_{i}}, res_{i}, r_{i}, HD_{i},
    \enc{\mathbf{HD'}_{i}}, \enc{\mathbf{HD}_{i}})$ }
\end{gameproof}
  }
  \caption{Game 0 - Server privacy game}
  \label{fig:game0protocol1server}
\end{figure}
\textit{Game 1} (Figure \ref{fig:game1protocol1server}). The computation of the
authentication result bit $res_{i}$ sent by the server to the client from the
decryption of the ciphertext \(\enc{\mathbf{HD'}_{i}}\) (its value in Game 0) is
changed into the result returned by $Verify(X_k, Y_{i})$, the change is
highlighted belows. By the correctness constraint of the protocol, this does not
change the value of $res_{i}$, so $\Pr[S_1] = \Pr[S_0]$.

\begin{figure}[htbp!] 
  \centering
  \fbox{
    \begin{gameproof}[nr=0]
  \gameprocedure[linenumbering, mode=text]{%
    $D_{k} \randomsample D_{bio}$\\
    $(\sk, \pk) \gets KeyGen$\\
    $\mathbf{X}_{k} \randomsample D_{k}$\\
    $\enc{\mathbf{X}_{k}} \gets Enc(\mathbf{X}_{k},\pk)$\\
    For $i=1,\dots,q$:\\
    $\mathbf{Y}_{i} \gets \{0,1\}^{n}$\\
    $\enc{\mathbf{Y}_{i}} \gets Enc(\mathbf{Y}_{i},\pk)$\\
    $verifierView1 \gets \mathbf{ZKPoPK1}((\sk,\mathbf{Y}_{i});(\pk,\enc{\mathbf{Y}_{i}}))$\\
    $\enc{\mathbf{HD}_{i}} = EvalDistance(\enc{\mathbf{X}_{k}},\enc{\mathbf{Y}_{i}})$\\
    $r_{i} \randomsample \mathbb{Z}_{t}$,$\enc{\mathbf{HD'}_{i}} = Add(\enc{\mathbf{HD}_{i}},\enc{r_{i}})$\\
    $HD'_{i} \gets Dec(\enc{\mathbf{HD'}_{i}},\sk)$\\
    $verifierView2 \gets \mathbf{ZKPoPK2}((\sk,\mathbf{HD'}_{i});(\pk,\enc{\mathbf{HD'}_{i}}))$\\
    $HD_{i} \gets HD'_{i} - r_{i}$\\
    \gamechange{$res_{i} \gets Verify(X_{k},Y_{i})$}\\
    $\beta \gets \adv(verifierView1, verifierView2, \enc{\mathbf{X}_{k}}, \enc{\mathbf{Y}_{i}}, res_{i}, r_{i}, HD_{i},
    \enc{\mathbf{HD'}_{i}}, \enc{\mathbf{HD}_{i}})$ }
\end{gameproof}
  }
  \caption{Game 1 - Server privacy game}
  \label{fig:game1protocol1server}
\end{figure}

\textit{Game 2} (Figure \ref{fig:game2protocol1server}). The computation of the
zero-knowledge protocol transcripts is modified: Instead of computing the
transcripts using the secret, we generate them using the statistical
zero-knowledge simulator algorithms for the zero-knowledge proofs. By the
zero-knowledge property, whose simulator has a $2^{-\lambda}$ statistical distance from the real distribution, the result of it being
$\Pr[S_2] - \Pr[S_1] \leq 2^{-\lambda}$.

\begin{figure}[htbp!] 
  \centering    
  \fbox{
\begin{gameproof}[nr=1]
  \gameprocedure[linenumbering, mode=text]{%
    $D_{k} \randomsample D_{bio}$\\
    $(\sk, \pk) \gets KeyGen$\\
    $\mathbf{X}_{k} \randomsample D_{k}$\\
    $\enc{\mathbf{X_{k}}} \gets Enc(\mathbf{X}_{k},\pk)$\\
    For $i=1,\dots,q$:\\
    $\mathbf{Y}_{i} \gets \{0,1\}^{n}$\\
    $\enc{\mathbf{Y}_{i}} \gets Enc(\mathbf{Y}_{i},\pk)$\\
    \gamechange{$verifierView1 \gets \mathbf{ZKPSimulator}$}\\
    $\enc{\mathbf{HD}_{i}} = EvalDistance(\enc{\mathbf{X}_{k}},\enc{\mathbf{Y}_{i}})$\\
    $r_{i} \randomsample \mathbb{Z}_{HD}$,$\enc{\mathbf{HD'}_{i}} = Add(\enc{\mathbf{HD}_{i}},\enc{r_{i}})$\\
    $HD'_{i} \gets Dec(\enc{\mathbf{HD'}_{i}},\sk)$\\
    \gamechange{$verifierView2 \gets \mathbf{ZKPSimulator}$}\\
    $HD_{i} \gets HD'_{i} - r_{i}$\\
    $res_{i} \gets Verify(X_{k},Y_{i})$\\
    $\beta \gets \adv(verifierView1, verifierView2, \enc{\mathbf{X}_{k}}, \enc{\mathbf{Y}_{i}}, res_{i}, r_{i}, HD_{i},
    \enc{\mathbf{HD'}_{i}}, \enc{\mathbf{HD}_{i}})$ }
\end{gameproof}
}
  \caption{Game 2 - Server privacy game}
  \label{fig:game2protocol1server}
\end{figure}
\textit{Game 3} (Figure \ref{fig:game3protocol1server}). We change the
computation of the ciphertexts $\enc{\mathbf{X}_{k}}$ to encrypt zero messages,
instead of encrypting the secret-related messages resulting from the previous
game. We also change the computation of $HD_{i}$ to the direct operation
$HammingDistance(\mathbf{X}_{k}, \mathbf{Y}_{i})$. Since $sk_k$ is thus not used
any longer for generating the view of $\attacker$, it follows by a hybrid
argument that
$|\Pr[S_3]-\Pr[S_2] \cdot (q + 1) \cdot
\varepsilon_{BV}$, where $\varepsilon_{BV}$ denotes the maximal advantage of an
attacker against IND-CPA of the BV scheme against attacks with run-time
$T + \mathrm{poly}(n, \log Q)$, where $T$ is the run-time of $\attacker$.  In
this game, since the only information on $X_k$ comes via the
$Verify(X_k,Y_k^{j})$ and $HammingDistance$ queries, the challenger together
with $\attacker$ constitute an efficient attacker against the ideal privacy
game, which outputs 1 with a degree of probability different by at most
$(l+1) \cdot q + 1) \cdot \varepsilon_{BV}$ from the probability of outputting 1
in the real privacy game, as required.

\begin{figure}[htbp!] 
  \centering
  \fbox{
    \begin{gameproof}[nr=2]
  \gameprocedure[linenumbering, mode=text]{%
    $D_{k} \randomsample D_{bio}$\\
    $(\sk, \pk) \gets KeyGen$\\
    $\mathbf{X}_{k} \randomsample D_{k}$\\
    \gamechange{$\enc{\mathbf{X_{k}}} \gets Enc(0,\pk)$}\\
    For $i=1,\dots,q$:\\
    $\mathbf{Y}_{i} \gets \{0,1\}^{n}$\\
    \gamechange{$\enc{\mathbf{Y}_{i}} \gets Enc(0,\pk)$}\\
    $verifierView1 \gets \mathbf{ZKPSimulator}$\\
    $\enc{\mathbf{HD}_{i}} = EvalDistance(\enc{\mathbf{X}_{k}},\enc{\mathbf{Y}_{i}})$\\
    $r_{i} \randomsample \mathbb{Z}_{HD}$,$\enc{\mathbf{HD'}_{i}} = Add(\enc{\mathbf{HD}_{i}},\enc{r_{i}})$\\
    $HD'_{i} \gets Dec(\enc{\mathbf{HD'}_{i}},\sk)$\\
    $verifierView2 \gets \mathbf{ZKPSimulator}$\\
    \gamechange{$HD_{i} \gets HammingDistance(\mathbf{X}_{k}, \mathbf{Y}_{i})$}\\
    $res_{i} \gets Verify(X_{k},Y_{i})$\\
    $\beta \gets \adv(verifierView1, verifierView2, \enc{\mathbf{X}_{k}}, \enc{\mathbf{Y}_{i}}, res_{i}, r_{i}, HD_{i},
    \enc{\mathbf{HD'}_{i}}, \enc{\mathbf{HD}_{i}})$ }
\end{gameproof}
  }
  \caption{Game 3 - Server privacy game}
  \label{fig:game3protocol1server}
\end{figure}

\begin{theorem}[Client side security]
  \label{theo:clientPro1}
  Under the IND-CPA security of BV cryptosystem and the soundness property of
  the underlying Stern protocol, the proposed scheme satisfies Impersonation and
  Multifactor Security.
\end{theorem}

The proof of theorem \ref{theo:clientPro1} can be obtained using a sequence of games
between the challenger $\challenger$ and the adversary $\attacker$. We here
present such a sequence, as well as the relations among the games, in order to
demonstrate the type I security model proof. In
the next chapter, we will present the type II
security proof, where the ciphertext of the biometric data instead of the key is compromised. The steps of the proofs can be applied in both the first
and the second variants of the protocols.

\textit{Game 0} (Figure \ref{fig:game0protocol1client}). Game 0 is the original
impersonation game for type I attack.
\begin{description}
\item [Setup.] $\challenger$ intiates $D_k \randomsample D_{bio}$ and
  $X_k \randomsample D_k$. $\challenger$ sets up $(sk_k, pk_k)$ and launches
  $Enrol(k, X_k)$ to get $(sk_k, \enc{\mathbf{X}_{k}} =(pk_k, \mathbf{X}_{k}))$.
  $\attacker$ submits a type 1 attack query and receives $sk_k$ from
  $\challenger$.
\item [Query.] $\attacker$ runs $q$ authentication sessions. In each session
  $j = 1, \dots, q$, $\attacker$ can choose a ciphertext. $\attacker$ and $\challenger$ run
  $\mathbf{ZKPoPK1}$. $\challenger$ evaluates $\enc{\mathbf{HD}_{k}}$ then
  computes $\enc{\mathbf{HD'}_{k}}$. The resulting ciphertext is sent to
  $\attacker$, $\attacker$ decrypts $\enc{\mathbf{HD'}_{k}}$ and sends back the
  plaintext value of $HD'_{i}$. $\attacker$ and $\challenger$ run
  $\mathbf{ZKPoPK2}()$. $\challenger$ computes $HD = HD' - r$, compares the result with $\tau$ sends back to $\attacker$ the authentication result $\mathbf{Accept}$ or \textbf{Reject}.
\item [Guess.] At the end of the game, $\adv$ outputs $\mathbf{Y'}$.
\end{description}

\begin{figure}[htbp!] 
  \centering
  \fbox{
   \begin{gameproof}[nr=-1]
     \gameprocedure[linenumbering, mode=text]{
       $D_{k} \randomsample D_{bio}$\\
       $(\sk, \pk) \gets KeyGen$\\
       $\mathbf{X}_{k} \randomsample D_{k}$\\
       $\enc{\mathbf{X_{k}}} \gets Enc(\mathbf{X}_{k},\pk)$\\
       For $i=1,\dots,q$:\\
       $\mathbf{Y}_{i} \gets \{0,1\}^{n}$\\
       $\enc{\mathbf{Y}_{i}} \gets Enc(\mathbf{Y}_{i},\pk)$\\
       $proverView1 \gets \mathbf{ZKPoPK1}((\sk,\mathbf{Y}_{i});(\pk,\enc{\mathbf{Y}_{i}}))$\\
       $\enc{\mathbf{HD}_{i}} = EvalDistance(\enc{\mathbf{X}_{k}},\enc{\mathbf{Y}_{i}})$\\
       $r_{i} \randomsample \mathbb{Z}_{HD}$,$\enc{\mathbf{HD'}_{i}} = Add(\enc{\mathbf{HD}_{i}},\enc{r_{i}})$\\
       $HD'_{i} \gets Dec(\enc{\mathbf{HD'}_{i}},\sk)$\\
       $proverView2 \gets \mathbf{ZKPoPK2}((\sk,\mathbf{HD'}_{i});(\pk,\enc{\mathbf{HD'}_{i}}))$\\
       $HD_{i} \gets HD'_{i} - r_{i}$\\
       $res_{i} \gets compare(HD_{i}, \tau)$\\
       $\beta \gets \adv(proverView1, proverView2, sk, \mathbf{Y}_{i},
       \enc{\mathbf{Y}_{i}}, res_{i}, HD'_{i}, \enc{\mathbf{HD'}_{i}})$
     }
\end{gameproof}
  }
  \caption{Game 0 - Client Impersonation game}
  \label{fig:game0protocol1client}
\end{figure}

Next, we discuss following games, the plan being to proceed towards the final
game, where everything related to $X_k$ that $\attacker$ receives can be simulated
without any knowledge about $X_k$ (the only known information about $X_k$ is the
function $Verify(X_k, Y_{i})$). Let $res_i = Verify(X_k, Y_{i})$ ($i = 1, \dots, q$) and $S_j$ be
the event in the game $j$ such that $res_i = Accept$ for some $Y_{i} \in {0,1}^{n}$.\\
\textit{Game 1}. In this game, we abort $\mathbf{ZKPoPK1}$ if $\enc{\mathbf{Y}_{i}}$ is
not a valid encryption of the query, but the $Prover$ manages to pass the
proof. Let $(*)_i$ be this event.
\[
  (*_1)res_i = \begin{cases}
    \text{Reject if } \mathbf{ZKPoPK1} \text{ fails}\\
    \text{res else}
  \end{cases}
\]
Let $bad_0$ be the event in game 0 and
$\exists j \leq q\ s.t\ (*_1)\ \textnormal{be the case}$. We want to show that
when we modify \textit{game 0}, the probability of a successful forgery $S_1$ in
\textit{game 1} is not much lower than before. Due to the modification, we
observe that $ Pr[S_1] \geq Pr[S_0] - Pr[bad_0] $. For any $j$ in the $q$
authentication attemps, by the $\varepsilon-soundness$ property of
$\mathbf{ZKPoPK1}$ as a proof of membership in (*),
$Pr[(*_1)\ occurs\ for\ some \ j] \leq \varepsilon_{ZK1}$ holds. That is, the
probability of $bad_0$ would be the union of these events, bounded by
$Pr[bad_0] \leq q\varepsilon_{ZK1}$. In other words, the advantage of
$\attacker$ in \textit{game 1} is
\[
  Pr[S_1] \geq Pr[S_0] - Pr[bad_0] \geq \varepsilon_{imp} - q\varepsilon_{ZK1}
\]
\\
\textit{Game 2}. In this game, we abort $\mathbf{ZKPoPK2}$ if in one of the
$i^{th}$ runs, the $Verifier$ accepts but the ciphertext $\enc{\mathbf{HD'}}$
does not satisfy the relation. Let $bad_1$ be this event. By the same type of
argument, we can derive $Pr[bad_1] \leq q\varepsilon_{ZK2}$ and, therefore,
$$Pr[S_2] \geq Pr[S_1]
- Pr[bad_1] \geq \varepsilon_{imp} - q(\varepsilon_{ZK1}+\varepsilon_{ZK2})
$$
By the end of \textit{Game 2}, if in any authentication attempt $i$, none of the
2 games have been aborted, then, by the correctness property of ZKP, the
server's output is equal to the output of $Verify(X_k, Y_{i})$. In other words,
we have shown what we could get by just querying the oracle $Verify()$. Next, we
want to simulate everything related to $X_k$ available to an attacker using that oracle.\\

\begin{figure}[htbp!] 
  \centering
  \fbox{
   \begin{gameproof}[nr=1]
     \gameprocedure[linenumbering, mode=text]{
       $D_{k} \randomsample D_{bio}$\\
       $(\sk, \pk) \gets KeyGen$\\
       $\mathbf{X}_{k} \randomsample D_{k}$\\
       $\enc{\mathbf{X_{k}}} \gets Enc(\mathbf{X}_{k},\pk)$\\
       For $i=1,\dots,q$:\\
       $\mathbf{Y}_{i} \gets \{0,1\}^{n}$\\
       $\enc{\mathbf{Y}_{i}} \gets Enc(\mathbf{Y}_{i},\pk)$\\
       \gamechange{$proverView1 \gets \mathbf{ZKPSimulator}()$}\\
       $\enc{\mathbf{HD}_{i}} = EvalDistance(\enc{\mathbf{X}_{k}},\enc{\mathbf{Y}_{i}})$\\
       $r_{i} \randomsample \mathbb{Z}_{HD}$,$\enc{\mathbf{HD'}_{i}} = Add(\enc{\mathbf{HD}_{i}},\enc{r_{i}})$\\
       $HD'_{i} \gets Dec(\enc{\mathbf{HD'}_{i}},\sk)$\\
       \gamechange{$proverView2 \gets \mathbf{ZKPSimulator}()$}\\
       $HD_{i} \gets HD'_{i} - r_{i}$\\
       $res_{i} \gets compare(HD_{i}, \tau)$\\
       $\beta \gets \adv(proverView1, proverView2, sk, \mathbf{Y}_{i},
       \enc{\mathbf{Y}_{i}}, res_{i}, HD'_{i}, \enc{\mathbf{HD'}_{i}})$
     }
\end{gameproof}
  }
  \caption{Game 1 \& 2 - Client Impersonation game}
  \label{fig:game2protocol1client}
\end{figure}

\textit{Game 3.} At the end of \textit{Game 2}, $\challenger$ has the bit
$b = Verify(Y^{(i)},X_k)$. In this game, we can change $res_{i}$ from
$compare(HD_{i},\tau)$ to $Verify(X_{k},Y_{i})$. By doing this change,
$\attacker$ still sees the same result, so the probability of winning of
$\attacker$ in this game is the same as in \textit{Game 2}: $\prob{S_{3}} = \prob{S_{2}}$
\\
\begin{figure}[htbp!] 
  \centering
  \fbox{
   \begin{gameproof}[nr=2]
     \gameprocedure[linenumbering, mode=text]{
       $D_{k} \randomsample D_{bio}$\\
       $(\sk, \pk) \gets KeyGen$\\
       $\mathbf{X}_{k} \randomsample D_{k}$\\
       $\enc{\mathbf{X_{k}}} \gets Enc(\mathbf{X}_{k},\pk)$\\
       For $i=1,\dots,q$:\\
       $\mathbf{Y}_{i} \gets \{0,1\}^{n}$\\
       $\enc{\mathbf{Y}_{i}} \gets Enc(\mathbf{Y}_{i},\pk)$\\
       {$proverView1 \gets \mathbf{ZKPSimulator}()$}\\
       $\enc{\mathbf{HD}_{i}} = EvalDistance(\enc{\mathbf{X}_{k}},\enc{\mathbf{Y}_{i}})$\\
       $r_{i} \randomsample \mathbb{Z}_{HD}$,$\enc{\mathbf{HD'}_{i}} = Add(\enc{\mathbf{HD}_{i}},\enc{r_{i}})$\\
       $HD'_{i} \gets Dec(\enc{\mathbf{HD'}_{i}},\sk)$\\
       {$proverView2 \gets \mathbf{ZKPSimulator}()$}\\
       $HD_{i} \gets HD'_{i} - r_{i}$\\
       \gamechange{$res_{i} \gets Verify(X_{k},Y_{i})$}\\
       $\beta \gets \adv(proverView1, proverView2, sk, \mathbf{Y}_{i},
       \enc{\mathbf{Y}_{i}}, res_{i}, HD'_{i}, \enc{\mathbf{HD'}_{i}})$
     }
\end{gameproof}
  }
  \caption{Game 3 - Client Impersonation game}
  \label{fig:game3protocol1client}
\end{figure}

\textit{Game 4.} In this game, we change the way $\challenger$ computes
$\enc{\mathbf{HD'}_{i}}$: In the orignal game 0, $r$ was added to mask the value
of $HD$. We want to prevent this $r$ from being used anywhere in the game, so we
replace $\enc{r}$ by $\enc{0}$. This change does not affect $\attacker$'s
success probability: $r$ only affects the plaintext inside $\enc{\mathbf{HD'}}$,
since we do not use this plaintext anymore (it has been replaced in \textit{Game
  3}), this
change therefore does not affect what the attacker sees. Again, $Pr[S_4] = Pr[S_3] = Pr[S_2]$.\\

\begin{figure}[htbp!] 
  \centering
  \fbox{
   \begin{gameproof}[nr=3]
     \gameprocedure[linenumbering, mode=text]{
       $D_{k} \randomsample D_{bio}$\\
       $(\sk, \pk) \gets KeyGen$\\
       $\mathbf{X}_{k} \randomsample D_{k}$\\
       $\enc{\mathbf{X_{k}}} \gets Enc(\mathbf{X}_{k},\pk)$\\
       For $i=1,\dots,q$:\\
       $\mathbf{Y}_{i} \gets \{0,1\}^{n}$\\
       $\enc{\mathbf{Y}_{i}} \gets Enc(\mathbf{Y}_{i},\pk)$\\
       $proverView1 \gets \mathbf{ZKPSimulator}()$\\
       $\enc{\mathbf{HD}_{i}} = EvalDistance(\enc{\mathbf{X}_{k}},\enc{\mathbf{Y}_{i}})$\\
       \gamechange{$r_{i} \gets 0, enc{\mathbf{HD'}_{i}} = Add(\enc{\mathbf{HD}_{i}},\enc{r_{i}})$}\\
       $HD'_{i} \gets Dec(\enc{\mathbf{HD'}_{i}},\sk)$\\
       $proverView2 \gets \mathbf{ZKPSimulator}()$\\
       $HD_{i} \gets HD'_{i} - r_{i}$\\
       $res_{i} \gets Verify(X_{k},Y_{i})$\\
       $\beta \gets \adv(proverView1, proverView2, sk, \mathbf{Y}_{i},
       \enc{\mathbf{Y}_{i}}, res_{i}, HD'_{i}, \enc{\mathbf{HD'}_{i}})$ }
  \end{gameproof}
  }
  \caption{Game 4 - Client Impersonation game}
  \label{fig:game3protocol1client}
\end{figure}
After \textit{Game 4} is finished, we can see that all the messages available to the attacker can be simulated using only the verified bit $b = Verify(Y^{(i)},
X_k)$. We now have an attacker $A'$ against the biometric impersonation with
advantage:
\[
\varepsilon_{bio} = Adv(A') = Pr[S_4] \geq (\varepsilon_{imp} - q(\varepsilon_{ZK1}+\varepsilon_{ZK2})) ,
\]
which results in the claimed bound.


\section{Result Evaluation}

\subsection{Parameters}
\label{sec:parameters}
We now consider how to set concrete parameters. From Lemma
\ref{le:hdcorrectness} and the analysis from \cite{naehrig2011can}, we can take
\(\sigma = 8\) to make the protocol secure against the lattice attacks
(\cite{micciancio2008lattice}), note that this setting does not cover circuit
privacy, which will be discussed in the next chapter. We can take \(t = 2048\)
to define the plaintext space ring \(R_{t}\), this is enough to cover Hamming
Distance of bit strings up to 2048 bits. We need \(n \geq 2048\) for the packing
ciphertext. With these parameters, we need \(q\) to be approximately 60 bits to
satisfy \(16n^{2}t^{2}\sigma^{4} < q\).  The proposed scheme works with only 1
level of homomorphic multiplication for the proposed set of parameters
$(n = 2048, q \approx 2^{60}, t = 2048, \sigma = 8)$, the proof of concept
implementation can be found in \cite{rimrimrq38:online}.

Number of rounds to repeat for each Zero Knowledge Proof: We are aiming at
matching the security of biometrics systems with False Acceptance Rate of
$10^{-3}$, hence, with the current ZKP technique whose soundness error is
$2/3$, we need to repeat the proof 17 times to achieve such level of
security. Following the the communication size computed from our result
($2(n\log q)\sum{l_{i}}$), where $\sum{l_{i}} \approx \sigma$ and the other
parameters chosen as above, the communication size of the two Zero Knowledge
Proofs required by the protocol is approximately 8MB to provide security against
a malicious client model.

\subsection{Limitations and open problems}
\label{sec:limitations}
We expose the HD to the server in the last step of the protocol and let the
server do the threshold comparison operation in the plaintext domain. We assume
that, given such a value, the server is not able to acquire any
information about the original bit strings template (assuming the provable
CPA-secure ciphertexts of the underlying cryptosystem). This assumption depends on the feature extraction function and would hold if the HD between a registered user's biometric template and another sample of that user's template is statistically independent of the registered template. Comparing the HD with threshold
homomorphhically proves much less efficient, and removing this assumption is
thus left as a topic of next chapters.

Also, we assume an honest but curious server, which is reasonable against
passive exposure attacks. Active attacks are harder to carry out undetected and
also slower, provided the server can be audited regularly. We emphasize that
previous quantum resistant protocols also made this assumption, and were not
even able to resist passive honest but curious trusted parties. Defending
privacy against a malicious server is left as an open problem.

Finally, the communication size of the Stern-based ZKP protocol is large, due to
the round soundness error \(2/3\) (many communication rounds will be needed for
security). We show how to reduce this overhead in chapter 6.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../thesis"
%%% End:
